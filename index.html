<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meijin Go System - Pro Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Serif+JP:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {

            --primary-dark: #1a1a2e;
            --primary: #162447;
            --secondary: #1f4068;
            --accent: #e43f5a;
            --accent-light: #ff6b8b;
            --success: #2ecc71;
            --success-light: #4cd97b;
            --warning: #f39c12;
            --danger: #e74c3c;
            --gold: #ffd700;
            --silver: #c0c0c0;
            --bronze: #cd7f32;
            --stone-black: #000000;
            --stone-white: #ffffff;
            --goban-light: #dcb35c;
            --goban-dark: #5d4037;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --bg-light: #f8f9fa;
            --bg-card: #ffffff;
            --border: #e0e0e0;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            --shadow-hover: 0 8px 30px rgba(0, 0, 0, 0.12);
            --radius-lg: 16px;
            --radius-md: 12px;
            --radius-sm: 8px;
        }

        [data-theme="dark"] {
            --primary-dark: #0d1117;
            --primary: #161b22;
            --secondary: #21262d;
            --accent: #ff7b72;
            --accent-light: #ffa198;
            --success: #238636;
            --success-light: #2ea043;
            --warning: #d29922;
            --danger: #f85149;
            --gold: #ffd700;
            --silver: #c0c0c0;
            --bronze: #cd7f32;
            --stone-black: #000000;
            --stone-white: #ffffff;
            --goban-light: #5d4037;
            --goban-dark: #3e2723;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --bg-light: #0d1117;
            --bg-card: #161b22;
            --border: #30363d;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            --shadow-hover: 0 8px 30px rgba(0, 0, 0, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .season-finale {
    border: 2px solid rgba(255, 215, 0, 0.3) !important;
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%) !important;
}


/* Lignes ~150-160 - LAISSER COMME √áA */
/* REMPLACEZ le CSS des onglets (lignes ~150-160) par : */
.tab-content {
    display: none;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
}

.tab-content.active {
    display: block;
    opacity: 1;
    visibility: visible;
}
.rewards-badge {
    background: linear-gradient(135deg, var(--gold) 0%, #FFA500 100%);
    color: black;
    padding: 4px 10px;
    border-radius: 20px;
    font-weight: bold;
    font-size: 0.8rem;
    display: inline-flex;
    align-items: center;
    gap: 5px;
}

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary) 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            margin-bottom: 30px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--stone-black) 0%, #333 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            font-weight: 700;
        }

        .logo-text {
            font-family: 'Noto Serif JP', serif;
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--gold) 0%, var(--accent-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .match-player.loser {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.1) 0%, transparent 100%) !important;
            border: 1px solid rgba(231, 76, 60, 0.3) !important;
            opacity: 0.7;
        }

        .match-player.loser .player-label {
            color: var(--danger) !important;
            text-decoration: line-through;
        }

        .match-player.loser .player-subtext {
            color: #e74c3c !important;
        }

        .match-player.loser .stone-display {
            opacity: 0.5;
            filter: grayscale(70%);
        }

        .guest-mode .win-btn,
        .guest-mode .swap-colors-btn,
        .guest-mode .quick-actions,
        .guest-mode .advanced-match-controls,
        .guest-mode .manual-control-indicator {
            display: none !important;
        }

        .guest-mode .match-status-badge {
            display: inline-flex !important;
        }

        .guest-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            background: var(--secondary);
            color: white;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 10px;
        }

        .admin-hidden {
            display: none !important;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .theme-toggle {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: var(--radius-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .auth-section {
            display: flex;
            gap: 10px;
        }

        .auth-input {
            padding: 10px 15px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--bg-card);
            color: var(--text-primary);
            min-width: 180px;
        }

        .btn {
            padding: 10px 24px;
            border-radius: var(--radius-md);
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(228, 63, 90, 0.3);
        }

        .btn-secondary {
            background: var(--secondary);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success) 0%, var(--success-light) 100%);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-warning {
            background: var(--warning);
            color: white;
        }

        .format-banner {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: 20px 30px;
            margin-bottom: 30px;
            border-left: 4px solid var(--gold);
            box-shadow: var(--shadow);
        }

        .format-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .format-details {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            color: var(--text-secondary);
        }

        .format-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        .format-item::before {
            content: "‚Ä¢";
            color: var(--accent);
            font-weight: bold;
        }

        .champion-section {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1) 0%, rgba(228, 63, 90, 0.1) 100%);
            border-radius: var(--radius-lg);
            padding: 40px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        .badge-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            display: inline-block;
            margin-top: 15px;
        }

        .champion-section::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 20% 50%, rgba(255, 215, 0, 0.1) 0%, transparent 50%);
        }

        .champion-title {
            font-family: 'Noto Serif JP', serif;
            font-size: 1.4rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        .champion-name {
            font-size: 3.5rem;
            font-weight: 900;
            text-align: center;
            background: linear-gradient(135deg, var(--gold) 0%, var(--accent-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .season-info {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 215, 0, 0.2);
        }

        .season-item {
            text-align: center;
            flex: 1;
            min-width: 200px;
        }

        .season-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--gold);
            margin-bottom: 5px;
        }

        .season-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 400px 1fr 400px;
            gap: 30px;
            margin-bottom: 40px;
        }

        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: 400px 1fr;
            }
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: 30px;
            margin-bottom: 25px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-hover);
        }

        .game-link {
            display: block;
            margin-top: 10px;
            padding: 6px 12px;
            background: var(--secondary);
            color: white;
            border-radius: 8px;
            text-decoration: none;
            font-size: 0.85rem;
            text-align: center;
        }

        .add-link-btn {
            display: block;
            margin-top: 10px;
            width: 100%;
            padding: 6px 12px;
            background: transparent;
            border: 1px dashed var(--border);
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .game-link:hover {
            background: var(--primary);
        }

        .add-link-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border);
        }

        .card-title {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .add-player-form {
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-md);
            padding: 20px;
            margin-bottom: 25px;
            border: 2px dashed var(--border);
            display: none;
        }

        .add-player-form.visible {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .form-grid {
            display: grid;
            grid-template-columns: 2fr 1fr auto;
            gap: 10px;
            align-items: end;
        }

        .form-input {
            padding: 12px 16px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(228, 63, 90, 0.1);
        }

        .rankings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .search-box {
            position: relative;
            flex: 1;
            max-width: 300px;
        }

        .win-btn {
            display: block;
            width: 100%;
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(46, 204, 113, 0.3);
        }

        .win-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(46, 204, 113, 0.4);
        }

        .win-btn:active {
            transform: translateY(-1px);
        }

        .win-btn[style*="background: #f39c12"] {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%) !important;
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.3);
        }

        .win-btn[style*="background: #f39c12"]:hover {
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }

        .badge-success {
            background: #2ecc71;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            margin-top: 15px;
            display: inline-block;
        }

        .search-input {
            width: 100%;
            padding: 12px 16px 12px 40px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-primary);
        }

        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }

        .filter-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .filter-btn {
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .filter-btn:hover,
        .filter-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .player-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .player-item {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            background: var(--bg-light);
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .player-item:hover {
            background: rgba(228, 63, 90, 0.05);
            border-color: var(--accent-light);
            transform: translateX(5px);
        }

        .player-item.top-3 {
            border-left: 4px solid;
        }

        .player-item:nth-child(1) {
            border-left-color: var(--gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
        }

        .player-item:nth-child(2) {
            border-left-color: var(--silver);
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.05) 0%, transparent 100%);
        }

        .player-item:nth-child(3) {
            border-left-color: var(--bronze);
            background: linear-gradient(135deg, rgba(205, 127, 50, 0.05) 0%, transparent 100%);
        }

        .player-rank {
            width: 40px;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-secondary);
            text-align: center;
        }

        .player-info {
            flex: 1;
            min-width: 0;
        }

        .player-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .player-meta {
            display: flex;
            gap: 12px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .player-tag {
            background: var(--secondary);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .match-player.winner {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.1) 0%, transparent 100%);
            border: 2px solid var(--success);
            position: relative;
        }

        .match-player.winner::after {
            content: "üèÜ";
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.5rem;
        }

        .player-stats {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .player-points {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--accent);
        }

        .player-record {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, var(--bg-light) 0%, transparent 100%);
            border-radius: var(--radius-md);
            padding: 20px;
            border: 1px solid var(--border);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .chart-container {
            position: relative;
            height: 320px;
            width: 100%;
            background: var(--bg-light);
            border-radius: var(--radius-md);
            padding: 20px;
            margin-top: 15px;
        }

        .tournament-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        

        .tournament-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent);
            margin: 0;
        }

        .tournament-meta {
            display: flex;
            gap: 15px;
            align-items: center;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .tournament-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .tournament-settings {
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-md);
            padding: 20px;
            margin: 20px 0;
            border: 1px solid var(--border);
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .pairing-section {
            background: linear-gradient(135deg, rgba(31, 64, 104, 0.1) 0%, transparent 100%);
            border-radius: var(--radius-md);
            padding: 25px;
            margin: 25px 0;
            border: 1px solid var(--border);
        }

        .pairing-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pairing-form {
            display: grid;
            grid-template-columns: 1fr auto 1fr auto;
            gap: 15px;
            align-items: center;
        }

        .vs-separator {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent);
            text-align: center;
        }

        .matches-grid {
            display: grid;
            gap: 15px;
            margin-top: 20px;
        }

        .match-card {
            background: var(--bg-light);
            border-radius: var(--radius-md);
            padding: 20px;
            border: 2px solid var(--border);
            transition: all 0.3s ease;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 30px;
            align-items: center;
        }

        .match-card.completed {
            border-color: var(--success);
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.05) 0%, transparent 100%);
        }

        .match-player {
            text-align: center;
            padding: 15px;
            border-radius: var(--radius-md);
            transition: all 0.3s ease;
            position: relative;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .stone-display {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 0 auto 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stone-display.black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
        }

        .stone-display.white {
            background: radial-gradient(circle at 30% 30%, #fff, #f0f0f0);
            border: 2px solid #ddd;
        }

        .swap-colors-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--warning);
            color: white;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(243, 156, 18, 0.3);
        }

        .swap-colors-btn:hover {
            transform: rotate(180deg);
            background: #e67e22;
            box-shadow: 0 4px 12px rgba(230, 126, 34, 0.4);
        }

        .player-label {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .player-subtext {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 15px;
        }

        .match-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
        }

        .match-status {
            text-align: center;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--accent);
            padding: 0 20px;
        }

        .enrollment-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
            margin: 25px 0;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }

        .enrollment-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-light);
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .enrollment-item:hover {
            background: rgba(228, 63, 90, 0.05);
            border-color: var(--accent-light);
        }

        .enrollment-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .enrollment-actions {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }

        .progress-container {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid var(--border);
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .progress-bar {
            height: 10px;
            background: var(--bg-light);
            border-radius: 5px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-light) 100%);
            transition: width 0.5s ease;
        }

        .history-grid {
            display: grid;
            gap: 15px;
        }

        .history-item {
            background: var(--bg-light);
            border-radius: var(--radius-md);
            padding: 20px;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .history-item:hover {
            transform: translateX(5px);
            border-color: var(--accent-light);
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .history-title {
            font-weight: 600;
            color: var(--text-primary);
        }

        .history-meta {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .history-stats {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            font-size: 0.9rem;
        }

        .history-stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .notification {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 16px 20px;
            border-left: 4px solid;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-width: 300px;
            max-width: 400px;
            animation: slideInRight 0.3s ease;
        }

        .notification.success {
            border-left-color: var(--success);
        }

        .notification.error {
            border-left-color: var(--danger);
        }

        .notification.info {
            border-left-color: var(--secondary);
        }

        .notification.warning {
            border-left-color: var(--warning);
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 20px;
                text-align: center;
            }

            .main-grid {
                grid-template-columns: 1fr;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }

            .pairing-form {
                grid-template-columns: 1fr;
            }

            .match-card {
                grid-template-columns: 1fr;
                text-align: center;
            }

            .match-status {
                padding: 15px 0;
            }

            .tournament-header {
                flex-direction: column;
                align-items: stretch;
            }

            .tournament-controls {
                justify-content: center;
            }

            .champion-name {
                font-size: 2.5rem;
            }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .badge-gold {
            background: var(--gold);
            color: var(--primary-dark);
        }

        .badge-silver {
            background: var(--silver);
            color: var(--primary-dark);
        }

        .badge-bronze {
            background: var(--bronze);
            color: white;
        }

        .tournament-type {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            background: var(--secondary);
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-light);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        .tabs {
            display: flex;
            border-bottom: 2px solid var(--border);
            margin-bottom: 20px;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-weight: 600;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--accent);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .round-progress {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        .round-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px;
            background: var(--bg-light);
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
        }

        .round-number {
            width: 36px;
            height: 36px;
            background: var(--secondary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

        .round-info {
            flex: 1;
        }

        .round-title {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .round-stats {
            display: flex;
            gap: 15px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .color-controls {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            gap: 10px;
        }

        .swap-colors-global-btn {
            background: var(--warning);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--radius-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .swap-colors-global-btn:hover {
            background: #e67e22;
            transform: rotate(5deg);
        }

        .advanced-match-controls {
            background: linear-gradient(135deg, rgba(31, 64, 104, 0.1) 0%, transparent 100%);
            border-radius: var(--radius-md);
            padding: 20px;
            margin: 20px 0;
            border: 1px solid var(--border);
        }

        .advanced-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .advanced-control-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .advanced-control-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .history-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-md);
            margin-top: 15px;
        }

        .history-details.expanded {
            max-height: 500px;
            padding: 15px;
            border: 1px solid var(--border);
        }

        .history-details-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .history-details-table th {
            text-align: left;
            padding: 8px 12px;
            background: var(--bg-light);
            color: var(--text-primary);
            font-weight: 600;
            border-bottom: 2px solid var(--border);
        }

        .history-details-table td {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            color: var(--text-secondary);
        }

        .history-details-table tr:hover {
            background: rgba(228, 63, 90, 0.05);
        }

        .player-select-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 15px 0;
        }

        .player-select-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
        }

        .swap-players-btn {
            background: var(--secondary);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .swap-players-btn:hover {
            transform: rotate(180deg);
            background: var(--primary);
        }

        .quick-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .quick-action-btn {
            padding: 8px 15px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-primary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .quick-action-btn:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .match-status-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 10px;
        }

        .match-status-pending {
            background: var(--warning);
            color: var(--primary-dark);
        }

        .match-status-completed {
            background: var(--success);
            color: white;
        }

        .match-status-cancelled {
            background: var(--danger);
            color: white;
        }

        .stone-display.swappable {
            cursor: pointer;
            position: relative;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .stone-display.swappable:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        .stone-display.swappable:hover::after {
            content: '‚Üª';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .history-expand-btn {
            background: none;
            border: none;
            color: var(--accent);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            border-radius: var(--radius-sm);
            transition: all 0.3s ease;
        }

        .history-expand-btn:hover {
            background: rgba(228, 63, 90, 0.1);
        }

        .history-actions {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        .history-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .history-filter {
            padding: 6px 12px;
            border-radius: 20px;
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .history-filter:hover,
        .history-filter.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .match-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        .match-result-select {
            width: 100%;
            padding: 8px 12px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-primary);
        }

        .history-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .history-stat-item {
            background: var(--bg-light);
            border-radius: var(--radius-md);
            padding: 12px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .history-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 5px;
        }

        .history-stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .manual-control-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 3px 8px;
            background: var(--warning);
            color: var(--primary-dark);
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 10px;
        }

        @keyframes colorSwap {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .color-swap-animation {
            animation: colorSwap 0.5s ease;
        }

        @media (max-width: 768px) {
            .advanced-controls-grid {
                grid-template-columns: 1fr;
            }
            
            .player-select-row {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .swap-players-btn {
                transform: rotate(90deg);
                margin: 0 auto;
            }
            
            .quick-actions {
                justify-content: center;
            }
            
            .history-details-table {
                display: block;
                overflow-x: auto;
            }

            .color-controls {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <div class="logo-icon">Á¢Å</div>
            <h1 class="logo-text">Meijin System</h1>
        </div>
        <div class="header-controls">
            <button onclick="toggleTheme()" class="theme-toggle">
                <span id="themeIcon">üåô</span> Theme
            </button>
            <div class="auth-section" id="authSection">
                <input type="password" id="adminPin" class="auth-input" placeholder="Admin PIN">
                <button onclick="loginAdmin()" class="btn btn-primary">Login</button>
            </div>
            <div id="adminControls" class="admin-hidden">
                <span style="margin-right: 15px; font-weight: 600; color: var(--accent);">Admin Mode</span>
                <button onclick="logoutAdmin()" class="btn btn-danger">Logout</button>
            </div>
        </div>
    </div>

    <!-- Game Format Banner -->
    <div class="format-banner">
        <div class="format-title">
            <span>üéÆ Game Format</span>
        </div>
        <div class="format-details">
            <div class="format-item">Fischer 45min + 15s increment</div>
            <div class="format-item">6.5 points komi</div>
            <div class="format-item">Tournaments 1-3: Swiss System</div>
            <div class="format-item">Tournament 4: Single Elimination</div>
            <div class="format-item">Top 2 after 3 tournaments auto-qualify</div>
        </div>
    </div>

    <!-- Champion Section -->
    <div id="championSection" class="champion-section">
        <div class="champion-title">CURRENT MEIJIN CHAMPION</div>
        <h1 id="currentChampion" class="champion-name">---</h1>
        <div class="season-info">
            <div class="season-item">
                <div class="season-value" id="currentSeason">1</div>
                <div class="season-label">Season</div>
            </div>
            <div class="season-item">
                <div class="season-value" id="tournamentInSeason">1/4</div>
                <div class="season-label">Tournament</div>
            </div>
            <div class="season-item">
                <div class="season-value" id="nextQualifiers">--</div>
                <div class="season-label">Auto-qualifiers</div>
            </div>
        </div>
    </div>

    <!-- Main Grid -->
    <div class="main-grid">
        <!-- Left Column -->
        <aside>
            <!-- Rankings Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üèÜ Global Rankings</h2>
                </div>

                <!-- Add Player Form (Admin Only) -->
                <div id="addPlayerForm" class="add-player-form admin-hidden">
                    <div class="form-grid">
                        <div>
                            <input type="text" id="newPlayerName" class="form-input" placeholder="Player name">
                        </div>
                        <div>
                            <select id="newPlayerRank" class="form-input">
                                <option value="30k">30k</option>
                                <option value="20k">20k</option>
                                <option value="10k">10k</option>
                                <option value="5k">5k</option>
                                <option value="1k" selected>1k</option>
                                <option value="1d">1d</option>
                                <option value="5d">5d</option>
                                <option value="9d">9d</option>
                            </select>
                        </div>
                        <div>
                            <button onclick="addNewPlayer()" class="btn btn-primary">Add</button>
                        </div>
                    </div>
                </div>

                <!-- Search and Filter -->
                <div class="rankings-header">
                    <div class="search-box">
                        <span class="search-icon">üîç</span>
                        <input type="text" id="searchPlayers" class="search-input" placeholder="Search players...">
                    </div>
                </div>

                <div class="filter-buttons">
                    <button onclick="filterPlayers('all')" class="filter-btn active">All</button>
                    <button onclick="filterPlayers('kyu')" class="filter-btn">Kyu (30k-1k)</button>
                    <button onclick="filterPlayers('dan')" class="filter-btn">Dan (1d-9d)</button>
                    <button onclick="filterPlayers('low')" class="filter-btn">30k-10k</button>
                    <button onclick="filterPlayers('mid')" class="filter-btn">5k-1d</button>
                    <button onclick="filterPlayers('high')" class="filter-btn">5d-9d</button>
                </div>

                <!-- Rankings List -->
                <div class="player-list" id="rankingsList">
                    <!-- Players will be listed here -->
                </div>
            </div>

            <!-- Statistics Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìä Statistics</h2>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalPlayers">0</div>
                        <div class="stat-label">Total Players</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalMatches">0</div>
                        <div class="stat-label">Total Matches</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgElo">1500</div>
                        <div class="stat-label">Avg Elo</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="winRate">0%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                </div>
            </div>

            <!-- Chart Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìà Points Evolution</h2>
                </div>
                <div class="chart-container">
                    <canvas id="seasonChart"></canvas>
                </div>
            </div>
        </aside>

        <!-- Middle Column -->
        <main>
            <!-- Tabs for Active/History/Archive -->
            <div class="tabs" id="tournamentTabs">
                <button class="tab active" onclick="switchTab('active')">üéØ Active Tournament</button>
                <button class="tab" onclick="switchTab('archive')">üìÅ Rounds Archive</button>
                <button class="tab" onclick="switchTab('history')">üìú Tournament History</button>
                <button class="tab admin-hidden" onclick="switchTab('manual')" id="manualTab">üõ†Ô∏è Manual Management</button>
            </div>

            <!-- Active Tournament -->
            <div id="activeTournamentCard" class="tab-content active">
                <div class="card">
                    <div class="tournament-header">
                        <div>
                            <h2 id="tournamentTitle" class="tournament-title">Active Tournament</h2>
                            <div class="tournament-meta">
                                <span>Round: <span id="currentRound">1</span>/<span id="totalRounds">3</span></span>
                                <span>Players: <span id="tournamentPlayerCount">0</span></span>
                                <span id="tournamentTypeBadge" class="tournament-type">
                                    <span id="tournamentTypeIcon">‚ôüÔ∏è</span>
                                    <span id="tournamentTypeText">Swiss System</span>
                                </span>
                            </div>
                        </div>
            <div class="tournament-controls admin-hidden">
    <button onclick="generateSwissPairs()" class="btn btn-secondary">
        <span>üîÄ</span> Generate Pairs
    </button>
    <button onclick="clearCurrentRoundMatches()" class="btn btn-warning">
        <span>üóëÔ∏è</span> Clear Round Matches
    </button>
    <button onclick="clearCurrentMatches()" class="btn btn-warning">
        <span>üîÑ</span> Next Round
    </button>
    <button onclick="endTournament()" class="btn btn-danger">
        <span>üèÅ</span> End Tournament
    </button>
</div>

                    <!-- Bouton d'inversion des couleurs global -->
                    <div class="color-controls admin-hidden" id="globalColorControls">
                        <button onclick="swapAllMatchColors()" class="swap-colors-global-btn">
                            <span>üé®</span> Swap All Colors
                        </button>
                        <button onclick="randomizeAllColors()" class="swap-colors-global-btn">
                            <span>üé≤</span> Randomize Colors
                        </button>
                    </div>

                    <!-- Tournament Settings -->
                    <div id="tournamentSettings" class="tournament-settings admin-hidden">
                        <div class="pairing-title">‚öôÔ∏è Tournament Settings</div>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <label class="setting-label">Number of Rounds:</label>
                                <input type="number" id="roundsCount" class="form-input" value="3" min="1" max="10">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Points per Win:</label>
                                <input type="number" id="pointsPerWin" class="form-input" value="10" min="1" max="100">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Points per Loss:</label>
                                <input type="number" id="pointsPerLoss" class="form-input" value="-5" min="-100" max="0">
                            </div>
                        </div>
                    </div>

                    <!-- Manual Pairing avec am√©liorations -->
                    <div id="manualPairingSection" class="pairing-section admin-hidden">
                        <div class="pairing-title">üîß Manual Pairing</div>
                        <div class="player-select-controls">
                            <div class="player-select-row">
                                <select id="player1Select" class="form-input">
                                    <option value="">Select player 1</option>
                                </select>
                                <button onclick="swapSelectedPlayers()" class="swap-players-btn">
                                    ‚áÑ
                                </button>
                                <select id="player2Select" class="form-input">
                                    <option value="">Select player 2</option>
                                </select>
                            </div>
                            <!-- Contr√¥les de couleur pour le match manuel -->
                            <div style="display: flex; gap: 10px; align-items: center; justify-content: center;">
                                <label style="display: flex; align-items: center; gap: 5px;">
                                    <input type="radio" id="manualBlack1" name="manualColor" value="player1" checked>
                                    <span>Player 1 is Black</span>
                                </label>
                                <button onclick="toggleManualColor()" class="swap-colors-global-btn" style="padding: 5px 10px;">
                                    ‚Üª Swap
                                </button>
                                <label style="display: flex; align-items: center; gap: 5px;">
                                    <input type="radio" id="manualBlack2" name="manualColor" value="player2">
                                    <span>Player 2 is Black</span>
                                </label>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 15px;">
                            <button onclick="createManualMatch()" class="btn btn-success" style="flex: 1;">
                                <span>‚ûï</span> Create Match
                            </button>
                            <button onclick="createMultipleMatches()" class="btn btn-secondary" style="flex: 1;">
                                <span>üìã</span> Create Multiple
                            </button>
                        </div>
                    </div>

                    <!-- Banni√®re des r√©compenses (visible seulement pour le dernier tournoi de la saison) -->
<div id="seasonRewardsBanner" class="format-banner" style="display: none; background: linear-gradient(135deg, rgba(255,215,0,0.15) 0%, rgba(255,165,0,0.1) 100%); border-left: 4px solid var(--gold); margin-top: 20px;">
    <div class="format-title">
        <span>üéÅ Last Tournament Rewards</span>
        <span style="font-size: 0.8rem; background: var(--gold); color: black; padding: 2px 8px; border-radius: 12px; font-weight: bold;">
            SPECIAL PRIZES
        </span>
    </div>
    <div class="format-details" style="grid-template-columns: repeat(3, 1fr); gap: 20px;">
        <div style="display: flex; flex-direction: column; gap: 5px;">
            <div style="display: flex; align-items: center; gap: 10px;">
                <div style="width: 30px; height: 30px; background: var(--gold); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1rem;">
                    1
                </div>
                <span style="font-weight: 600; color: var(--text-primary);">ü•á 1st Place</span>
            </div>
            <div style="font-size: 0.9rem; color: var(--text-secondary); margin-left: 40px;" id="reward1">
                30% off coupon
            </div>
        </div>
        
        <div style="display: flex; flex-direction: column; gap: 5px;">
            <div style="display: flex; align-items: center; gap: 10px;">
                <div style="width: 30px; height: 30px; background: var(--silver); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1rem;">
                    2
                </div>
                <span style="font-weight: 600; color: var(--text-primary);">ü•à 2nd Place</span>
            </div>
            <div style="font-size: 0.9rem; color: var(--text-secondary); margin-left: 40px;" id="reward2">
                $10 off coupon
            </div>
        </div>
        
        <div style="display: flex; flex-direction: column; gap: 5px;">
            <div style="display: flex; align-items: center; gap: 10px;">
                <div style="width: 30px; height: 30px; background: var(--bronze); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1rem;">
                    3
                </div>
                <span style="font-weight: 600; color: var(--text-primary);">ü•â 3rd Place</span>
            </div>
            <div style="font-size: 0.9rem; color: var(--text-secondary); margin-left: 40px;" id="reward3">
                One-hour personalized lesson with Hugo
            </div>
        </div>
    </div>
    <div style="margin-top: 15px; font-size: 0.85rem; color: var(--text-secondary); font-style: italic;">
        Rewards apply only to this last tournament of the season
    </div>
</div>

                    <!-- Gestion manuelle avanc√©e -->
                    <div class="advanced-match-controls admin-hidden">
                        <div class="pairing-title">üõ†Ô∏è Advanced Match Management</div>
                        <div class="advanced-controls-grid">
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">
                                    <span>üéØ</span> Force Winner
                                </label>
                                <select id="forceWinnerSelect" class="form-input">
                                    <option value="">Select winner (optional)</option>
                                </select>
                            </div>
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">
                                    <span>üé®</span> Initial Color
                                </label>
                                <select id="forceColorSelect" class="form-input">
                                    <option value="random">Random</option>
                                    <option value="player1">Player 1 Black</option>
                                    <option value="player2">Player 2 Black</option>
                                </select>
                            </div>
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">
                                    <span>üìä</span> Custom Points
                                </label>
                                <input type="number" id="customPoints" class="form-input" placeholder="Default points">
                            </div>
                        </div>
                    </div>

                    <!-- Round Progress -->
                    <div class="round-progress" id="roundProgressSection">
                        <!-- Round progress will be displayed here -->
                    </div>

                    <!-- Matches Zone -->
                    <div class="matches-grid" id="matchesZone">
                        <!-- Matches will be displayed here -->
                    </div>

                    <!-- Tournament Progress -->
                    <div class="progress-container">
                        <div class="progress-header">
                            <span>Tournament Progress</span>
                            <span id="tournamentProgressText">Round 1/3</span>
                        </div>
                        <div class="progress-bar">
                            <div id="tournamentProgressFill" class="progress-fill" style="width: 0%"></div>
                        </div>
                        <div style="text-align: center; margin-top: 10px; font-size: 0.9rem; color: var(--text-secondary);">
                            <span id="matchesCompleted">0</span> matches completed ‚Ä¢ 
                            <span id="totalMatchesEstimate">0</span> total matches estimated
                        </div>
                    </div>
                </div>
            </div>

            <!-- Rounds Archive Card -->
            <div id="roundsArchiveCard" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üìÅ Rounds Archive</h2>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">
                            <span id="currentTournamentName">Current Tournament</span> ‚Ä¢ 
                            <span id="archivedRoundsCount">0</span> rounds archived
                        </div>
                    </div>
                    
                    <!-- Filtres pour les rounds -->
                    <div class="history-filters" id="roundsFilters">
                        <button class="history-filter active" onclick="filterRounds('all')">All Rounds</button>
                        <button class="history-filter" onclick="filterRounds('completed')">Completed</button>
                        <button class="history-filter" onclick="filterRounds('current')">Current Round</button>
                        <button class="history-filter" onclick="filterRounds('withGames')">With Game Links</button>
                    </div>
                    
                    <!-- Statistiques des rounds -->
                    <div class="history-stats-grid">
                        <div class="history-stat-item">
                            <div class="history-stat-value" id="totalArchivedMatches">0</div>
                            <div class="history-stat-label">Total Matches</div>
                        </div>
                        <div class="history-stat-item">
                            <div class="history-stat-value" id="completedArchivedMatches">0</div>
                            <div class="history-stat-label">Completed</div>
                        </div>
                        <div class="history-stat-item">
                            <div class="history-stat-value" id="roundsWithGames">0</div>
                            <div class="history-stat-label">With Game Links</div>
                        </div>
                        <div class="history-stat-item">
                            <div class="history-stat-value" id="avgMatchesPerRound">0</div>
                            <div class="history-stat-label">Avg/Round</div>
                        </div>
                    </div>
                    
                    <!-- Liste des rounds archiv√©s -->
                    <div class="rounds-archive-list" id="roundsArchiveList" style="margin-top: 20px;">
                        <!-- Les rounds seront affich√©s ici -->
                    </div>
                    
                    <!-- Bouton pour archiver manuellement le round actuel -->
                    <div class="admin-hidden" style="margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--border);">
                        <div style="text-align: center;">
                            <button onclick="manuallyArchiveCurrentRound()" class="btn btn-secondary">
                                <span>üì•</span> Archive Current Round (Round <span id="currentRoundNumber">1</span>)
                            </button>
                            <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 10px;">
                                This will save the current round to archive without ending the tournament
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tournament History -->
            <div id="tournamentHistoryCard" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üìú Tournament History</h2>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">
                            Total: <span id="totalTournaments">0</span> tournaments
                        </div>
                    </div>

                    <!-- Filtres pour l'historique -->
                    <div class="history-filters">
                        <button class="history-filter active" onclick="filterHistory('all')">All</button>
                        <button class="history-filter" onclick="filterHistory('season1')">Season 1</button>
                        <button class="history-filter" onclick="filterHistory('swiss')">Swiss System</button>
                        <button class="history-filter" onclick="filterHistory('elimination')">Elimination</button>
                        <button class="history-filter" onclick="filterHistory('recent')">Recent</button>
                    </div>

                    <!-- Statistiques de l'historique -->
                    <div class="history-stats-grid">
                        <div class="history-stat-item">
                            <div class="history-stat-value" id="historyTotalMatches">0</div>
                            <div class="history-stat-label">Total Matches</div>
                        </div>
                        <div class="history-stat-item">
                            <div class="history-stat-value" id="historyAvgPlayers">0</div>
                            <div class="history-stat-label">Avg Players</div>
                        </div>
                        <div class="history-stat-item">
                            <div class="history-stat-value" id="historyTotalWins">0</div>
                            <div class="history-stat-label">Total Wins</div>
                        </div>
                        <div class="history-stat-item">
                            <div class="history-stat-value" id="historyMostWins">---</div>
                            <div class="history-stat-label">Most Wins</div>
                        </div>
                    </div>

                    <div class="history-grid" id="tournamentHistoryList">
                        <!-- Tournament history will be displayed here -->
                    </div>
                </div>
            </div>

            

            <!-- Onglet de gestion manuelle -->
            <div id="manualManagementCard" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üõ†Ô∏è Manual Match Management</h2>
                        <span class="manual-control-indicator">Advanced Controls</span>
                    </div>

                    <!-- Actions rapides -->
                    <div class="quick-actions">
                        <button onclick="resetAllMatchColors()" class="quick-action-btn">
                            <span>üé®</span> Reset All Colors
                        </button>
                        <button onclick="clearAllMatches()" class="quick-action-btn">
                            <span>üóëÔ∏è</span> Clear All Matches
                        </button>
                        <button onclick="randomizeAllMatches()" class="quick-action-btn">
                            <span>üé≤</span> Randomize All
                        </button>
                        <button onclick="exportTournamentData()" class="quick-action-btn">
                            <span>üì§</span> Export Data
                        </button>
                    </div>

                    <!-- √âdition de match individuel -->
                    <div class="pairing-section">
                        <div class="pairing-title">‚úèÔ∏è Edit Specific Match</div>
                        <div class="advanced-controls-grid">
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">Select Match</label>
                                <select id="editMatchSelect" class="form-input" onchange="loadMatchForEditing()">
                                    <option value="">Select match to edit...</option>
                                </select>
                            </div>
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">Set Result</label>
                                <select id="editMatchResult" class="form-input">
                                    <option value="">Select result...</option>
                                    <option value="player1">Player 1 Wins</option>
                                    <option value="player2">Player 2 Wins</option>
                                    <option value="draw">Draw</option>
                                    <option value="cancelled">Cancelled</option>
                                </select>
                            </div>
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">Swap Players</label>
                                <button onclick="swapMatchPlayers()" class="btn btn-secondary" style="width: 100%;">
                                    ‚áÑ Swap Players
                                </button>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button onclick="saveMatchChanges()" class="btn btn-success" style="flex: 1;">
                                üíæ Save Changes
                            </button>
                            <button onclick="deleteSelectedMatch()" class="btn btn-danger" style="flex: 1;">
                                üóëÔ∏è Delete Match
                            </button>
                        </div>
                    </div>

                    <!-- Gestion en masse -->
                    <div class="pairing-section" style="margin-top: 20px;">
                        <div class="pairing-title">üì¶ Bulk Operations</div>
                        <div class="advanced-controls-grid">
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">
                                    <input type="checkbox" id="bulkSelectAll">
                                    Select All Matches
                                </label>
                                <div style="display: flex; gap: 10px; margin-top: 10px;">
                                    <button onclick="setBulkWinner('player1')" class="quick-action-btn" style="flex: 1;">
                                        Player 1 Wins All
                                    </button>
                                    <button onclick="setBulkWinner('player2')" class="quick-action-btn" style="flex: 1;">
                                        Player 2 Wins All
                                    </button>
                                </div>
                            </div>
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">Apply to Round</label>
                                <select id="bulkRoundSelect" class="form-input">
                                    <option value="all">All Rounds</option>
                                    <option value="current">Current Round Only</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Pr√©visualisation des changements -->
                    <div class="pairing-section" style="margin-top: 20px; display: none;" id="previewChanges">
                        <div class="pairing-title">üëÅÔ∏è Preview Changes</div>
                        <div id="previewContent" style="background: var(--bg-light); padding: 15px; border-radius: var(--radius-md);">
                            <!-- Pr√©visualisation des changements -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tournament Setup -->
            <div id="tournamentSetupCard" class="card admin-hidden">
                <div class="card-header">
                    <h2 class="card-title">üéØ New Tournament</h2>
                    <div style="color: var(--text-secondary); font-size: 0.9rem;">
                        Season: <span id="currentSeasonNum">1</span> ‚Ä¢ Tournament: <span id="nextTournamentNumber">1</span>/4
                    </div>
                </div>

                <div style="margin: 20px 0;">
                    <input type="text" id="tournamentName" class="form-input" placeholder="Tournament name" 
                           style="width: 100%; font-size: 1.1rem; padding: 15px;">
                </div>

                <h3 style="margin-bottom: 15px; color: var(--text-primary);">Select Participants</h3>
                <div id="enrollmentZone" class="enrollment-grid">
                    <!-- Players will be listed here -->
                </div>

                <div class="enrollment-actions">
                    <button onclick="selectAllPlayers()" class="btn btn-secondary" style="flex: 1;">
                        <span>‚úÖ</span> Select All
                    </button>
                    <button onclick="deselectAllPlayers()" class="btn btn-secondary" style="flex: 1;">
                        <span>‚ùå</span> Deselect All
                    </button>
                    <button onclick="startNewTournament()" id="startTournamentBtn" class="btn btn-primary" style="flex: 2;">
                        <span>üöÄ</span> Start Tournament
                    </button>
                </div>
            </div>
                  
        </main>

        <!-- Right Column -->
        <aside>
            <!-- Season Overview -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìÖ Season Overview</h2>
                </div>
                <div id="seasonTimeline">
                    <!-- Season timeline will be displayed here -->
                </div>
                <div style="margin-top: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span>Season Progress</span>
                        <span id="seasonProgressText">0/4</span>
                    </div>
                    <div class="progress-bar">
                        <div id="seasonProgressFill" class="progress-fill" style="width: 0%"></div>
                    </div>
                </div>
            </div>

            <!-- Recent Matches -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">‚ö° Recent Matches</h2>
                </div>
                <div id="recentMatchesList">
                    <!-- Recent matches will be displayed here -->
                </div>
            </div>

            <!-- System Info -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">‚ÑπÔ∏è System Info</h2>
                </div>
                <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.8;">
                    <p>üîπ <strong>Season System:</strong> 4 tournaments per season</p>
                    <p>üîπ <strong>Tournaments 1-3:</strong> Swiss system</p>
                    <p>üîπ <strong>Tournament 4:</strong> Single elimination</p>
                    <p>üîπ <strong>Auto-qualifiers:</strong> Top 2 after 3 tournaments</p>
                    <p>üîπ <strong>Points:</strong> Win: +10, Loss: -5</p>
                    <p>üîπ <strong>Elo System:</strong> K-factor: 32</p>
                </div>
            </div>
        </aside>
    </div>
</div>

<!-- Notification Container -->
<div id="notificationContainer" class="notification-container"></div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, doc, onSnapshot, updateDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    
        // R√©compenses de saison - D√âPLAC√â ICI
    const SEASON_REWARDS = {
        1: "30% off coupon",
        2: "$10 off coupon", 
        3: "One-hour personalized lesson with Hugo"
    };

    const firebaseConfig = {
        apiKey: "AIzaSyDzse9aVDIAFscTbGs-3Disy2wdRHWPRF0",
        authDomain: "meijin-system.firebaseapp.com",
        projectId: "meijin-system",
        storageBucket: "meijin-system.firebasestorage.app",
        messagingSenderId: "935283801474",
        appId: "1:935283801474:web:4e161bff3b1c6ffb77a39b"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
let state = {
    players: [],
    activeTournament: null,
    tournamentHistory: [],
    season: 1,
    tournamentCount: 0,
    champion: "None",
    autoQualifiers: [],
    lastAction: "System initialized",
    systemSettings: {
        pointsPerWin: 10,
        pointsPerLoss: -5,
        initialElo: 1500,
        eloKFactor: 32,
        roundsPerTournament: 3
    },
    eloRatings: {},
    seasonHistory: [],
    roundHistory: [] // ‚Üê AJOUT√â ICI
};

    let isAdmin = false;
    let chart = null;

    // Fonction pour masquer/afficher les √©l√©ments admin
    function toggleAdminElements(show) {
        const adminElements = document.querySelectorAll('.admin-hidden');
        adminElements.forEach(el => {
            if (show) {
                el.classList.remove('admin-hidden');
            } else {
                el.classList.add('admin-hidden');
            }
        });
    }

    // Theme Management
    function toggleTheme() {
        const currentTheme = document.body.getAttribute('data-theme') || 'light';
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        document.body.setAttribute('data-theme', newTheme);
        localStorage.setItem('meijin-theme', newTheme);
        
        const themeIcon = document.getElementById('themeIcon');
        themeIcon.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        
        if (chart) {
            chart.destroy();
            renderChart();
        }
        
        showNotification(`${newTheme.charAt(0).toUpperCase() + newTheme.slice(1)} theme activated`, 'info');
    }

    // Admin Authentication
    function loginAdmin() {
        const pin = document.getElementById('adminPin').value;
        if (pin === "159753") {
            isAdmin = true;
            document.getElementById('authSection').style.display = 'none';
            document.getElementById('adminControls').style.display = 'flex';
            toggleAdminElements(true);
            updateModeIndicator();
            showNotification('Admin login successful - Advanced controls enabled', 'success');
        } else {
            showNotification('Incorrect PIN', 'error');
        }
    }

    function logoutAdmin() {
        isAdmin = false;
        document.getElementById('authSection').style.display = 'flex';
        document.getElementById('adminControls').style.display = 'none';
        toggleAdminElements(false);
        updateModeIndicator();
        showNotification('Logged out successfully', 'info');
    }

    // Notification System
    function showNotification(message, type = 'info') {
        const container = document.getElementById('notificationContainer');
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = `
            <div style="flex: 1;">${message}</div>
            <button onclick="this.parentElement.remove()" style="background: none; border: none; color: inherit; cursor: pointer; margin-left: 10px; font-size: 1.2rem;">√ó</button>
        `;
        
        container.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentElement) {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => notification.remove(), 300);
            }
        }, 5000);
    }

    // Firebase Initialization
    const systemRef = doc(db, "system", "current");

    onSnapshot(systemRef, (docSnap) => {
    if (docSnap.exists()) {
        const data = docSnap.data();
        state = {
            ...state,
            ...data,
            players: data.players || [],
            activeTournament: data.activeTournament || null,
            tournamentHistory: data.tournamentHistory || [],
            tournamentCount: data.tournamentCount || 0,
            season: data.season || 1,
            champion: data.champion || "None",
            autoQualifiers: data.autoQualifiers || [],
            systemSettings: data.systemSettings || state.systemSettings,
            eloRatings: data.eloRatings || {},
            seasonHistory: data.seasonHistory || [],
            roundHistory: data.roundHistory || [] // ‚Üê AJOUT√â ICI
        };
            updateUI();
            updateSeasonInfo();
            updateTournamentHistory();
            updateHistoryStatistics();
        } else {
            setDoc(systemRef, state).catch(console.error);
        }
    });
function debugRoundArchive() {
    console.log("=== DEBUG ROUND ARCHIVE ===");
    console.log("Active tournament ID:", state.activeTournament?.id);
    console.log("Round history:", state.roundHistory);
    console.log("Round history length:", state.roundHistory?.length || 0);
    
    if (state.roundHistory && state.roundHistory.length > 0) {
        console.log("Round details:");
        state.roundHistory.forEach((round, index) => {
            console.log(`Round ${index}:`, {
                id: round.id,
                tournamentId: round.tournamentId,
                tournamentName: round.tournamentName,
                roundNumber: round.roundNumber,
                matches: round.matches?.length || 0,
                date: round.date
            });
        });
    }
}
    // Tab Switching
  function switchTab(tabName) {
    console.log("üîÑ Switching to tab:", tabName);
    
    // 1. D√©sactiver tous les tabs
    document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // 2. Cacher TOUS les contenus d'onglet AVEC FORCE
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
        content.style.display = 'none';
        content.style.opacity = '0';
        content.style.visibility = 'hidden';
    });
    
    // 3. Activer le tab cliqu√©
    const tabs = document.querySelectorAll('.tab');
    tabs.forEach((tab, index) => {
        if (tab.getAttribute('onclick') && tab.getAttribute('onclick').includes(tabName)) {
            tab.classList.add('active');
            tab.style.borderBottom = '2px solid var(--accent)';
        }
    });
    
    // 4. Afficher SEULEMENT le contenu correspondant AVEC FORCE
    let activeCard = null;
    
    switch(tabName) {
        case 'active':
            activeCard = document.getElementById('activeTournamentCard');
            console.log("üìä Showing Active Tournament");
            break;
            
        case 'archive':
            activeCard = document.getElementById('roundsArchiveCard');
            console.log("üìÅ Showing Rounds Archive");
            break;
            
        case 'history':
            activeCard = document.getElementById('tournamentHistoryCard');
            console.log("üìú Showing Tournament History");
            break;
            
        case 'manual':
            activeCard = document.getElementById('manualManagementCard');
            console.log("üõ†Ô∏è Showing Manual Management");
            break;
    }
    
    if (activeCard) {
        activeCard.classList.add('active');
        activeCard.style.display = 'block';
        activeCard.style.opacity = '1';
        activeCard.style.visibility = 'visible';
        
        // FORCER l'appel de updateRoundsArchive pour l'onglet archive
        if (tabName === 'archive') {
            console.log("üîÑ FORCING updateRoundsArchive with visual display");
            setTimeout(() => {
                if (typeof updateRoundsArchive === 'function') {
                    updateRoundsArchive();
                    
                    // Forcer l'affichage visuel apr√®s g√©n√©ration
                    setTimeout(() => {
                        if (activeCard) {
                            activeCard.style.display = 'block !important';
                            activeCard.style.opacity = '1 !important';
                            activeCard.style.visibility = 'visible !important';
                        }
                    }, 50);
                }
            }, 10);
        }
    }
    
    console.log("‚úÖ Tab switch completed for:", tabName);
}

// Ajoutez cette fonction apr√®s la fonction switchTab()
function testArchiveTab() {
    console.log("üß™ Testing Archive Tab...");
    
    // 1. Simuler un clic sur l'onglet Archive
    const archiveTab = document.querySelector('[onclick*="archive"]');
    if (archiveTab) {
        console.log("Found archive tab, clicking...");
        archiveTab.click();
    } else {
        console.log("Archive tab not found, forcing display...");
        // Forcer l'affichage manuellement
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        
        // Activer le tab Archive
        document.querySelector('[onclick*="archive"]')?.classList.add('active');
        document.getElementById('roundsArchiveCard').classList.add('active');
        
        // Appeler updateRoundsArchive
        setTimeout(() => {
            if (typeof updateRoundsArchive === 'function') {
                console.log("Calling updateRoundsArchive...");
                updateRoundsArchive();
            }
        }, 50);
    }
}

// Exposez-la globalement
window.testArchiveTab = testArchiveTab;


    // =================================================================
    // NOUVELLES FONCTIONNALIT√âS
    // =================================================================

    // 1. Inversion des couleurs pour tous les matchs
    async function swapAllMatchColors() {
        if (!isAdmin || !state.activeTournament) {
            showNotification('Admin access required', 'error');
            return;
        }

        const currentRound = state.activeTournament.round;
        const updatedMatches = state.activeTournament.matches.map(match => {
            if (match.round === currentRound) {
                return {
                    ...match,
                    player1IsBlack: !match.player1IsBlack
                };
            }
            return match;
        });

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('All colors swapped for current round', 'success');
    }

    // 2. Randomisation des couleurs
    async function randomizeAllColors() {
        if (!isAdmin || !state.activeTournament) {
            showNotification('Admin access required', 'error');
            return;
        }

        const currentRound = state.activeTournament.round;
        const updatedMatches = state.activeTournament.matches.map(match => {
            if (match.round === currentRound) {
                return {
                    ...match,
                    player1IsBlack: Math.random() > 0.5
                };
            }
            return match;
        });

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('All colors randomized', 'success');
    }

    // 3. √âchange des joueurs s√©lectionn√©s
    function swapSelectedPlayers() {
        const player1Select = document.getElementById('player1Select');
        const player2Select = document.getElementById('player2Select');
        
        const tempValue = player1Select.value;
        const tempText = player1Select.options[player1Select.selectedIndex].text;
        
        player1Select.value = player2Select.value;
        player1Select.options[player1Select.selectedIndex].text = player2Select.options[player2Select.selectedIndex].text;
        
        player2Select.value = tempValue;
        player2Select.options[player2Select.selectedIndex].text = tempText;
        
        // Inverser aussi la s√©lection des couleurs
        const player1Black = document.getElementById('manualBlack1').checked;
        document.getElementById('manualBlack1').checked = !player1Black;
        document.getElementById('manualBlack2').checked = player1Black;
    }

    // 4. Toggle des couleurs manuelles
    function toggleManualColor() {
        const player1Black = document.getElementById('manualBlack1').checked;
        document.getElementById('manualBlack1').checked = !player1Black;
        document.getElementById('manualBlack2').checked = player1Black;
    }

    // 5. Cr√©ation de matchs multiples
    async function createMultipleMatches() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const participants = state.activeTournament.participants || [];
        if (participants.length < 2) {
            showNotification('Not enough players', 'error');
            return;
        }

        // Cr√©er des matchs al√©atoires pour les joueurs non appari√©s
        const currentRound = state.activeTournament.round;
        const existingMatches = state.activeTournament.matches.filter(m => m.round === currentRound);
        const pairedPlayers = new Set();
        
        existingMatches.forEach(match => {
            pairedPlayers.add(match.player1.id);
            pairedPlayers.add(match.player2.id);
        });

        const availablePlayers = participants.filter(p => !pairedPlayers.has(p.id));
        const newMatches = [];

        // M√©langer les joueurs disponibles
        const shuffledPlayers = [...availablePlayers].sort(() => Math.random() - 0.5);

        for (let i = 0; i < shuffledPlayers.length - 1; i += 2) {
            const newMatch = {
                id: Date.now() + Math.random(),
                player1: shuffledPlayers[i],
                player2: shuffledPlayers[i + 1],
                winner: null,
                round: currentRound,
                player1IsBlack: Math.random() > 0.5,
                createdAt: new Date().toISOString(),
                gameUrl: null
            };
            newMatches.push(newMatch);
        }

        if (newMatches.length > 0) {
            const updatedMatches = [...state.activeTournament.matches, ...newMatches];
            await updateDoc(systemRef, { 
                "activeTournament.matches": updatedMatches
            });
            
            showNotification(`Created ${newMatches.length} new matches`, 'success');
        } else {
            showNotification('No new matches could be created', 'info');
        }
    }

    // 6. Filtrage de l'historique
    function filterHistory(filterType) {
        document.querySelectorAll('.history-filter').forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
        
        showNotification(`Filtering history: ${filterType}`, 'info');
    }

    // 7. Statistiques de l'historique
    function updateHistoryStatistics() {
        const totalMatches = state.tournamentHistory.reduce((sum, t) => sum + (t.matches?.length || 0), 0);
        const avgPlayers = state.tournamentHistory.length > 0 
            ? Math.round(state.tournamentHistory.reduce((sum, t) => sum + (t.participants?.length || 0), 0) / state.tournamentHistory.length)
            : 0;
        
        // Compter les victoires par joueur
        const winCounts = {};
        state.tournamentHistory.forEach(tournament => {
            tournament.matches?.forEach(match => {
                if (match.winner) {
                    winCounts[match.winner] = (winCounts[match.winner] || 0) + 1;
                }
            });
        });
        
        let mostWinsPlayer = '---';
        let mostWinsCount = 0;
        
        Object.entries(winCounts).forEach(([playerId, count]) => {
            if (count > mostWinsCount) {
                const player = state.players.find(p => p.id === playerId);
                if (player) {
                    mostWinsPlayer = player.name.substring(0, 10);
                    mostWinsCount = count;
                }
            }
        });
        
        document.getElementById('historyTotalMatches').textContent = totalMatches;
        document.getElementById('historyAvgPlayers').textContent = avgPlayers;
        document.getElementById('historyTotalWins').textContent = Object.values(winCounts).reduce((a, b) => a + b, 0);
        document.getElementById('historyMostWins').textContent = mostWinsPlayer;
    }

    // 8. Gestion manuelle avanc√©e
    async function resetAllMatchColors() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const updatedMatches = state.activeTournament.matches.map(match => ({
            ...match,
            player1IsBlack: true
        }));

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('All colors reset to default', 'success');
    }

    async function clearAllMatches() {
        if (!isAdmin || !confirm('Clear all matches in current round?')) {
            return;
        }

        const currentRound = state.activeTournament.round;
        const updatedMatches = state.activeTournament.matches.filter(match => match.round !== currentRound);

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('All matches cleared for current round', 'success');
    }

// Fonction pour effacer les matches de la ronde actuelle
async function clearCurrentRoundMatches() {
    if (!isAdmin) {
        showNotification('Admin access required', 'error');
        return;
    }

    if (!state.activeTournament) {
        showNotification('No active tournament', 'error');
        return;
    }

    const currentRound = state.activeTournament.round;
    const matchesThisRound = state.activeTournament.matches.filter(m => m.round === currentRound);
    
    if (matchesThisRound.length === 0) {
        showNotification(`No matches in round ${currentRound} to clear`, 'warning');
        return;
    }

    if (!confirm(`Clear ${matchesThisRound.length} matches from round ${currentRound}? This action cannot be undone.`)) {
        return;
    }

    try {
        // Filtrer pour ne garder que les matches des autres rounds
        const updatedMatches = state.activeTournament.matches.filter(m => m.round !== currentRound);
        
        await updateDoc(systemRef, {
            "activeTournament.matches": updatedMatches,
            lastAction: `üóëÔ∏è Cleared ${matchesThisRound.length} matches from round ${currentRound}`
        });
        
        showNotification(`‚úÖ Cleared ${matchesThisRound.length} matches from round ${currentRound}`, 'success');
        
        // Mettre √† jour l'affichage
        updateMatchesDisplay();
        
    } catch (error) {
        console.error("Error clearing matches:", error);
        showNotification("Error clearing matches: " + error.message, 'error');
    }
}

// Exposer la fonction globalement pour y acc√©der depuis la console
window.clearCurrentRoundMatches = clearCurrentRoundMatches;

    async function randomizeAllMatches() {
        if (!isAdmin || !confirm('Randomize all matches in current round?')) {
            return;
        }

        const currentRound = state.activeTournament.round;
        const participants = state.activeTournament.participants || [];
        const shuffledParticipants = [...participants].sort(() => Math.random() - 0.5);
        
        const newMatches = [];
        for (let i = 0; i < shuffledParticipants.length - 1; i += 2) {
            newMatches.push({
                id: Date.now() + Math.random(),
                player1: shuffledParticipants[i],
                player2: shuffledParticipants[i + 1],
                winner: null,
                round: currentRound,
                player1IsBlack: Math.random() > 0.5,
                createdAt: new Date().toISOString(),
                gameUrl: null
            });
        }

        // Supprimer les anciens matchs du round courant
        const filteredMatches = state.activeTournament.matches.filter(m => m.round !== currentRound);
        const updatedMatches = [...filteredMatches, ...newMatches];

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification(`Randomized ${newMatches.length} matches`, 'success');
    }

    function exportTournamentData() {
        const data = {
            tournament: state.activeTournament,
            exportDate: new Date().toISOString(),
            players: state.activeTournament?.participants || []
        };
        
        const dataStr = JSON.stringify(data, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportFileDefaultName = `meijin-tournament-${new Date().toISOString().split('T')[0]}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
        
        showNotification('Tournament data exported', 'success');
    }

    // 9. Chargement des matchs pour √©dition
    function loadMatchForEditing() {
        const matchId = document.getElementById('editMatchSelect').value;
        if (!matchId) return;
        
        const match = state.activeTournament.matches.find(m => m.id === matchId);
        if (match) {
            document.getElementById('editMatchResult').value = match.winner || '';
            showNotification(`Loaded match: ${match.player1.name} vs ${match.player2.name}`, 'info');
        }
    }

    // 10. √âchange des joueurs dans un match sp√©cifique
    async function swapMatchPlayers() {
        const matchId = document.getElementById('editMatchSelect').value;
        if (!matchId) {
            showNotification('Select a match first', 'error');
            return;
        }

        const updatedMatches = state.activeTournament.matches.map(match => {
            if (match.id === matchId) {
                return {
                    ...match,
                    player1: match.player2,
                    player2: match.player1,
                    player1IsBlack: !match.player1IsBlack,
                    winner: match.winner === match.player1.id ? match.player2.id : 
                           match.winner === match.player2.id ? match.player1.id : 
                           match.winner
                };
            }
            return match;
        });

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('Players swapped in selected match', 'success');
    }

    // 11. Sauvegarde des modifications d'un match
    async function saveMatchChanges() {
        const matchId = document.getElementById('editMatchSelect').value;
        const result = document.getElementById('editMatchResult').value;
        
        if (!matchId) {
            showNotification('Select a match first', 'error');
            return;
        }

        const match = state.activeTournament.matches.find(m => m.id === matchId);
        if (!match) return;

        let updatedMatch = { ...match };
        
        // Mettre √† jour le r√©sultat
        if (result) {
            switch(result) {
                case 'player1':
                    updatedMatch.winner = match.player1.id;
                    break;
                case 'player2':
                    updatedMatch.winner = match.player2.id;
                    break;
                case 'draw':
                    updatedMatch.winner = 'draw';
                    break;
                case 'cancelled':
                    updatedMatch.winner = null;
                    updatedMatch.cancelled = true;
                    break;
            }
            
            if (result !== 'cancelled' && result !== 'draw') {
                const winnerId = result === 'player1' ? match.player1.id : match.player2.id;
                const loserId = result === 'player1' ? match.player2.id : match.player1.id;
                
                const winnerElo = state.eloRatings[winnerId] || state.systemSettings.initialElo;
                const loserElo = state.eloRatings[loserId] || state.systemSettings.initialElo;
                const eloChanges = calculateElo(winnerElo, loserElo, state.systemSettings.eloKFactor);
                
                updatedMatch.eloChanges = {
                    winner: { from: winnerElo, to: eloChanges.newWinnerElo },
                    loser: { from: loserElo, to: eloChanges.newLoserElo }
                };
            }
        }

        const updatedMatches = state.activeTournament.matches.map(m => 
            m.id === matchId ? updatedMatch : m
        );

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('Match updated successfully', 'success');
    }

    // 12. Suppression d'un match
    async function deleteSelectedMatch() {
        const matchId = document.getElementById('editMatchSelect').value;
        if (!matchId || !confirm('Delete this match?')) {
            return;
        }

        const updatedMatches = state.activeTournament.matches.filter(m => m.id !== matchId);
        
        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        document.getElementById('editMatchSelect').value = '';
        document.getElementById('editMatchResult').value = '';
        
        showNotification('Match deleted', 'success');
    }

    // 13. Op√©rations en masse
    async function setBulkWinner(winnerType) {
        if (!isAdmin || !confirm(`Set all matches to ${winnerType === 'player1' ? 'Player 1 wins' : 'Player 2 wins'}?`)) {
            return;
        }

        const currentRound = state.activeTournament.round;
        const roundFilter = document.getElementById('bulkRoundSelect').value;
        
        const updatedMatches = state.activeTournament.matches.map(match => {
            const matchInRound = match.round === currentRound;
            const applyToMatch = roundFilter === 'all' || (roundFilter === 'current' && matchInRound);
            
            if (applyToMatch && !match.winner) {
                return {
                    ...match,
                    winner: winnerType === 'player1' ? match.player1.id : match.player2.id
                };
            }
            return match;
        });

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('Bulk operation completed', 'success');
    }

    // =================================================================
    // FONCTIONS EXISTANTES
    // =================================================================

    // Elo Rating System
    function calculateElo(winnerElo, loserElo, kFactor = 32) {
        const expectedScoreWinner = 1 / (1 + Math.pow(10, (loserElo - winnerElo) / 400));
        const newWinnerElo = Math.round(winnerElo + kFactor * (1 - expectedScoreWinner));
        const newLoserElo = Math.round(loserElo + kFactor * (0 - (1 - expectedScoreWinner)));
        
        return { newWinnerElo, newLoserElo };
    }
function displayTournamentRoundsDetails(rounds) {
    console.log("üìã displayTournamentRoundsDetails called with:", rounds?.length || 0, "rounds");
    
    if (!rounds || rounds.length === 0) {
        return '<div style="color: var(--text-secondary); padding: 10px; text-align: center;">No rounds archived</div>';
    }
    
    let html = '';
    
    rounds.forEach((round, roundIndex) => {
        const roundDate = round.date ? new Date(round.date).toLocaleDateString('en-US', {
            day: '2-digit',
            month: 'short',
            hour: '2-digit',
            minute: '2-digit'
        }) : 'Date inconnue';
        
        html += `
            <div style="margin-bottom: 20px; padding: 10px; border-bottom: 1px solid var(--border);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <strong style="color: var(--accent);">Round ${round.roundNumber || roundIndex + 1}</strong>
                    <small style="color: var(--text-secondary);">${roundDate}</small>
                </div>
        `;
        
        if (round.matches && round.matches.length > 0) {
            round.matches.forEach((match, matchIndex) => {
                const player1Name = match.player1?.name || 'Player 1';
                const player2Name = match.player2?.name || 'Player 2';
                const winnerName = match.winnerName || 
                    (match.winner === match.player1?.id ? player1Name : 
                     match.winner === match.player2?.id ? player2Name : null);
                
                html += `
                    <div style="margin: 5px 0; padding: 8px; background: rgba(255,255,255,0.05); border-radius: var(--radius-sm);">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-weight: ${match.winner === match.player1?.id ? 'bold' : 'normal'}; 
                                  color: ${match.winner === match.player1?.id ? 'var(--success)' : 'inherit'};">
                                ${player1Name}
                            </span>
                            <span style="color: var(--text-secondary);">vs</span>
                            <span style="font-weight: ${match.winner === match.player2?.id ? 'bold' : 'normal'};
                                  color: ${match.winner === match.player2?.id ? 'var(--success)' : 'inherit'};">
                                ${player2Name}
                            </span>
                        </div>
                        ${match.winner ? 
                            `<div style="font-size: 0.8rem; color: var(--success); margin-top: 3px;">
                                üèÜ Winner: ${winnerName}
                            </div>` : 
                            `<div style="font-size: 0.8rem; color: var(--warning); margin-top: 3px;">
                                ‚è≥ No result
                            </div>`
                        }
                        ${match.gameLink ? 
                            `<div style="font-size: 0.7rem; margin-top: 3px;">
                                üîó <a href="${match.gameLink}" target="_blank" style="color: var(--secondary);">Game link</a>
                            </div>` : ''
                        }
                    </div>
                `;
            });
        } else {
            html += '<div style="color: var(--text-secondary); font-size: 0.8rem;">No match details</div>';
        }
        
        html += `</div>`;
    });
    
    console.log("‚úÖ HTML generated for rounds details");
    return html;
}
    // Auto Qualifiers Logic
    function updateAutoQualifiers() {
        const sortedPlayers = [...state.players].sort((a, b) => {
            if (a.elo !== undefined && b.elo !== undefined) {
                return b.elo - a.elo;
            }
            return (b.points || 0) - (a.points || 0);
        });
        
        const tournamentInSeason = (state.tournamentCount % 4) + 1;
        document.getElementById('tournamentInSeason').textContent = `${tournamentInSeason}/4`;
        
        if (tournamentInSeason >= 3) {
            const qualifiers = sortedPlayers.slice(0, 2).map(p => p.name);
            
            document.getElementById('nextQualifiers').textContent = qualifiers[0] && qualifiers[1] ? 
                `${qualifiers[0].substring(0, 10)} & ${qualifiers[1].substring(0, 10)}` : '--';
            
            if (JSON.stringify(state.autoQualifiers) !== JSON.stringify(qualifiers)) {
                state.autoQualifiers = qualifiers;
                updateDoc(systemRef, { autoQualifiers: qualifiers });
            }
        } else {
            document.getElementById('nextQualifiers').textContent = '--';
        }
    }
    // Player Management
    async function addNewPlayer() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const name = document.getElementById('newPlayerName').value.trim();
        const rank = document.getElementById('newPlayerRank').value;

        if (!name) {
            showNotification('Please enter a name', 'error');
            return;
        }

        if (state.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
            showNotification('Player already exists', 'error');
            return;
        }

        const newPlayer = {
            id: Date.now().toString(),
            name,
            rank,
            points: 0,
            wins: 0,
            losses: 0,
            draws: 0,
            elo: state.systemSettings.initialElo,
            history: [0],
            joinedDate: new Date().toISOString(),
            tournamentsPlayed: 0
        };

        const updatedPlayers = [...state.players, newPlayer];
        const updatedEloRatings = {
            ...state.eloRatings,
            [newPlayer.id]: state.systemSettings.initialElo
        };
        
        await updateDoc(systemRef, { 
            players: updatedPlayers,
            eloRatings: updatedEloRatings
        });
        
        document.getElementById('newPlayerName').value = '';
        showNotification(`Player "${name}" added successfully`, 'success');
    }

    // Tournament Management
    async function startNewTournament() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const name = document.getElementById('tournamentName').value.trim() || 
                     `Season ${state.season} - Tournament ${(state.tournamentCount % 4) + 1}`;
        const enrolled = Array.from(document.querySelectorAll('.enroll-check:checked')).map(cb => cb.value);

        if (enrolled.length < 2) {
            showNotification('Select at least 2 players', 'error');
            return;
        }

        const participants = state.players.filter(p => enrolled.includes(p.id));
        
        const tournamentInSeason = (state.tournamentCount % 4) + 1;
        const tournamentType = tournamentInSeason === 4 ? 'single-elimination' : 'swiss';
        
        const roundsCount = parseInt(document.getElementById('roundsCount').value) || 3;
        
        const tournament = {
            id: Date.now().toString(),
            name,
            participants,
            matches: [],
            startTime: new Date().toISOString(),
            status: 'active',
            round: 1,
            totalRounds: roundsCount,
            type: tournamentType,
            settings: {
                pointsPerWin: parseInt(document.getElementById('pointsPerWin').value) || 10,
                pointsPerLoss: parseInt(document.getElementById('pointsPerLoss').value) || -5
            },
            roundProgress: Array(roundsCount).fill(0).map((_, i) => ({
                round: i + 1,
                completedMatches: 0,
                totalMatches: Math.floor(participants.length / 2)
            })),
            seedings: participants.map(p => ({ 
                id: p.id, 
                seed: (state.eloRatings[p.id] || state.systemSettings.initialElo) + Math.random() 
            })).sort((a, b) => b.seed - a.seed)
        };

        tournament.roundProgress.forEach(round => {
            round.totalMatches = Math.floor(participants.length / 2);
        });

        await updateDoc(systemRef, { 
            activeTournament: tournament,
            lastAction: `üéØ Tournament "${name}" started with ${participants.length} players`
        });

        showNotification(`Tournament "${name}" started!`, 'success');
    }

    // Fonction pour ajouter/modifier un lien de jeu
    async function promptGameLink(matchId) {
    console.log("üîó promptGameLink called for match:", matchId);
    console.log("Type du matchId:", typeof matchId);
    
    if (!isAdmin) {
        showNotification('‚ùå Admin access required', 'error');
        return;
    }
    
    if (!state.activeTournament) {
        showNotification('‚ùå No active tournament', 'error');
        return;
    }
    
    // DEBUG: Afficher les matchs
    console.log("üîç Recherche du match ID:", matchId);
    console.log("üîç Nombre de matchs disponibles:", state.activeTournament.matches.length);
    
    // Recherche am√©lior√©e du match
    let match = null;
    
    // Essai 1: Recherche exacte
    match = state.activeTournament.matches.find(m => m.id === matchId);
    
    if (!match) {
        // Essai 2: Recherche avec conversion
        match = state.activeTournament.matches.find(m => String(m.id) === String(matchId));
    }
    
    if (!match) {
        // Essai 3: Recherche avec conversion implicite
        match = state.activeTournament.matches.find(m => m.id == matchId);
    }
    
    if (!match) {
        console.error("‚ùå Match non trouv√©!");
        console.error("ID recherch√©:", matchId);
        console.error("Matchs disponibles:", state.activeTournament.matches.map(m => ({
            id: m.id,
            type: typeof m.id,
            players: `${m.player1?.name} vs ${m.player2?.name}`
        })));
        showNotification('‚ùå Match not found', 'error');
        return;
    }
    
    console.log("‚úÖ Match trouv√©:", match);
    
    const currentLink = match.gameUrl || "";
    const player1Name = match.player1.name.split(" ")[0];
    const player2Name = match.player2.name.split(" ")[0];
    
    const newLink = prompt(
        `üîó Game link for:\n${player1Name} vs ${player2Name}\n\nPaste OGS or KGS link:`,
        currentLink
    );
    
    if (newLink === null) {
        return;
    }
    
    const updatedMatches = state.activeTournament.matches.map(m => {
        // Utiliser la m√™me logique de recherche pour trouver le bon match
        const isSameMatch = 
            (m.id === matchId) || 
            (String(m.id) === String(matchId)) || 
            (m.id == matchId);
        
        if (isSameMatch) {
            return {
                ...m,
                gameUrl: newLink.trim() || null
            };
        }
        return m;
    });
    
    try {
        await updateDoc(systemRef, {
            "activeTournament.matches": updatedMatches
        });
        
        if (newLink.trim()) {
            showNotification(`‚úÖ Link added for ${player1Name} vs ${player2Name}`, "success");
        } else {
            showNotification(`‚úÖ Link removed`, "success");
        }
        
        // Mettre √† jour l'affichage localement aussi
        state.activeTournament.matches = updatedMatches;
        updateMatchesDisplay();
        
    } catch (error) {
        console.error("Firebase error:", error);
        showNotification("‚ùå Save error: " + error.message, "error");
    }
}

// Ajoutez cette fonction apr√®s les d√©clarations de variables (ligne ~130)
function debugMatches() {
    if (!state.activeTournament) {
        console.log("‚ùå Pas de tournoi actif");
        return;
    }
    
    console.log("=== D√âBOGAGE DES MATCHS ===");
    console.log("Tournoi:", state.activeTournament.name);
    console.log("Round actuel:", state.activeTournament.round);
    console.log("Nombre total de matchs:", state.activeTournament.matches?.length || 0);
    
    // Matchs du round actuel
    const currentRoundMatches = state.activeTournament.matches.filter(m => m.round === state.activeTournament.round);
    console.log("Matchs du round actuel:", currentRoundMatches.length);
    
    if (state.activeTournament.matches && state.activeTournament.matches.length > 0) {
        console.log("\nüìã Liste compl√®te des matchs:");
        state.activeTournament.matches.forEach((match, index) => {
            console.log(`\n--- Match ${index} ---`);
            console.log("ID:", match.id, "(type:", typeof match.id + ")");
            console.log("Joueurs:", `${match.player1?.name} vs ${match.player2?.name}`);
            console.log("Round:", match.round);
            console.log("Vainqueur:", match.winner || "Pas encore");
            console.log("Lien de jeu:", match.gameUrl || "Aucun");
        });
    } else {
        console.log("Aucun match dans ce tournoi");
    }
    
    // Afficher aussi les IDs des boutons dans le DOM
    console.log("\nüîç IDs dans le DOM:");
    const matchElements = document.querySelectorAll('[data-match-id]');
    matchElements.forEach((el, i) => {
        console.log(`Bouton ${i}: data-match-id="${el.dataset.matchId}"`);
    });
}

// Exposez-la globalement
window.debugMatches = debugMatches;
    async function createManualMatch() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const p1Id = document.getElementById('player1Select').value;
        const p2Id = document.getElementById('player2Select').value;

        if (!p1Id || !p2Id) {
            showNotification('Select two players', 'error');
            return;
        }

        if (p1Id === p2Id) {
            showNotification('Player cannot play against themselves', 'error');
            return;
        }

        const p1 = state.activeTournament.participants.find(p => p.id === p1Id);
        const p2 = state.activeTournament.participants.find(p => p.id === p2Id);

        const existingMatch = state.activeTournament.matches.find(m => 
            ((m.player1.id === p1Id && m.player2.id === p2Id) ||
            (m.player1.id === p2Id && m.player2.id === p1Id)) &&
            m.round === state.activeTournament.round
        );

        if (existingMatch) {
            showNotification('Match already exists in this round', 'error');
            return;
        }

        const player1IsBlack = document.getElementById('manualBlack1').checked;

        const newMatch = {
            id: Date.now().toString(),
            player1: p1,
            player2: p2,
            winner: null,
            round: state.activeTournament.round,
            player1IsBlack: player1IsBlack,
            createdAt: new Date().toISOString(),
            gameUrl: null
        };

        const updatedMatches = [...state.activeTournament.matches, newMatch];
        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches,
            lastAction: `‚öîÔ∏è New match: ${p1.name} (${player1IsBlack ? 'Black' : 'White'}) vs ${p2.name} (${!player1IsBlack ? 'Black' : 'White'})`
        });
        
        showNotification('Match created successfully', 'success');
    }

    // Fonction pour √©changer les couleurs d'un match
    async function swapMatchColors(matchId) {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const updatedMatches = state.activeTournament.matches.map(match => {
            if (match.id === matchId) {
                return {
                    ...match,
                    player1IsBlack: !match.player1IsBlack
                };
            }
            return match;
        });

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        const stoneDisplay = document.querySelector(`[data-match-id="${matchId}"] .stone-display`);
        if (stoneDisplay) {
            stoneDisplay.classList.add('color-swap-animation');
            setTimeout(() => stoneDisplay.classList.remove('color-swap-animation'), 500);
        }
        
        showNotification('Colors swapped', 'info');
    }

    // Fonction pour d√©clarer un vainqueur
    async function setMatchWinner(matchId, winnerId) {
    console.log("=== DEBUG setMatchWinner ===");
    console.log("matchId re√ßu:", matchId, "type:", typeof matchId);
    console.log("winnerId re√ßu:", winnerId, "type:", typeof winnerId);
    
    if (!isAdmin) {
        showNotification('Admin access required', 'error');
        return;
    }

    if (!state || !state.activeTournament || !state.activeTournament.matches) {
        console.error("‚ùå Erreur: Pas de tournoi actif ou pas de matchs");
        showNotification('No active tournament found', 'error');
        return;
    }

    // DEBUG: Afficher tous les matchs avec leurs IDs
    console.log("üîç Tous les matchs disponibles (" + state.activeTournament.matches.length + "):");
    state.activeTournament.matches.forEach((m, i) => {
        console.log(`[${i}] ID: "${m.id}" (type: ${typeof m.id}), Match: ${m.player1?.name} vs ${m.player2?.name}, Round: ${m.round}`);
    });

    // Recherche am√©lior√©e du match
    let match = null;
    
    // Essai 1: Recherche exacte
    match = state.activeTournament.matches.find(m => m.id === matchId);
    console.log("Recherche exacte (===):", match ? "‚úÖ Trouv√©" : "‚ùå Non trouv√©");
    
    if (!match) {
        // Essai 2: Recherche avec conversion en string
        match = state.activeTournament.matches.find(m => String(m.id) === String(matchId));
        console.log("Recherche avec String():", match ? "‚úÖ Trouv√©" : "‚ùå Non trouv√©");
    }
    
    if (!match) {
        // Essai 3: Recherche avec == (conversion implicite)
        match = state.activeTournament.matches.find(m => m.id == matchId);
        console.log("Recherche avec == :", match ? "‚úÖ Trouv√©" : "‚ùå Non trouv√©");
    }
    
    if (!match) {
        // Essai 4: Recherche par approximation (pour les nombres flottants)
        match = state.activeTournament.matches.find(m => 
            Math.abs(Number(m.id) - Number(matchId)) < 0.0001
        );
        console.log("Recherche par approximation:", match ? "‚úÖ Trouv√©" : "‚ùå Non trouv√©");
    }
    
    if (!match) {
        console.error("‚ùå Match non trouv√© avec aucun des m√©thodes de recherche!");
        console.error("ID recherch√©:", matchId);
        console.error("Type de l'ID recherch√©:", typeof matchId);
        showNotification('Match not found', 'error');
        return;
    }

    console.log("‚úÖ Match trouv√©:", {
        id: match.id,
        player1: match.player1.name,
        player2: match.player2.name,
        round: match.round,
        winner: match.winner
    });

    const loserId = winnerId === match.player1.id ? match.player2.id : match.player1.id;
    
    const winner = state.players.find(p => p.id === winnerId);
    const loser = state.players.find(p => p.id === loserId);

    if (!winner || !loser) {
        showNotification('Players not found', 'error');
        return;
    }

    // Calculate Elo changes
    const winnerElo = state.eloRatings[winnerId] || state.systemSettings.initialElo;
    const loserElo = state.eloRatings[loserId] || state.systemSettings.initialElo;
    const eloChanges = calculateElo(winnerElo, loserElo, state.systemSettings.eloKFactor);
    
    // Update Elo ratings
    const updatedEloRatings = {
        ...state.eloRatings,
        [winnerId]: eloChanges.newWinnerElo,
        [loserId]: eloChanges.newLoserElo
    };

    // Update players
    const pointsPerWin = state.activeTournament?.settings?.pointsPerWin || 10;
    const pointsPerLoss = state.activeTournament?.settings?.pointsPerLoss || -5;

    const updatedPlayers = state.players.map(p => {
        if (p.id === winnerId) {
            return {
                ...p,
                points: (p.points || 0) + pointsPerWin,
                wins: (p.wins || 0) + 1,
                elo: eloChanges.newWinnerElo,
                history: [...(p.history || [0]), (p.points || 0) + pointsPerWin],
                tournamentsPlayed: (p.tournamentsPlayed || 0) + 1
            };
        }
        if (p.id === loserId) {
            return {
                ...p,
                points: Math.max(0, (p.points || 0) + pointsPerLoss),
                losses: (p.losses || 0) + 1,
                elo: eloChanges.newLoserElo,
                history: [...(p.history || [0]), Math.max(0, (p.points || 0) + pointsPerLoss)],
                tournamentsPlayed: (p.tournamentsPlayed || 0) + 1
            };
        }
        return p;
    });

    // Update match
    const updatedMatches = state.activeTournament.matches.map(m => 
        m.id === match.id || String(m.id) === String(match.id) ? { 
            ...m, 
            winner: winnerId,
            eloChanges: {
                winner: { from: winnerElo, to: eloChanges.newWinnerElo },
                loser: { from: loserElo, to: eloChanges.newLoserElo }
            },
            endedAt: new Date().toISOString()
        } : m
    );

    // Update round progress
    const currentRound = state.activeTournament.round;
    let roundProgress = state.activeTournament.roundProgress || [];
    
    if (!Array.isArray(roundProgress)) {
        const participants = state.activeTournament.participants || [];
        const totalRounds = state.activeTournament.totalRounds || 3;
        roundProgress = Array(totalRounds).fill(0).map((_, i) => ({
            round: i + 1,
            completedMatches: 0,
            totalMatches: Math.floor(participants.length / 2)
        }));
    }

    const roundIndex = currentRound - 1;
    
    if (roundIndex >= 0 && roundIndex < roundProgress.length) {
        const completedMatches = updatedMatches.filter(m => 
            m.round === currentRound && m.winner
        ).length;
        
        roundProgress[roundIndex] = {
            ...roundProgress[roundIndex],
            completedMatches: completedMatches
        };
    }

    console.log("üíæ Sauvegarde des modifications...");
    
    try {
        await updateDoc(systemRef, {
            players: updatedPlayers,
            eloRatings: updatedEloRatings,
            "activeTournament.matches": updatedMatches,
            "activeTournament.roundProgress": roundProgress,
            lastAction: `üèÜ ${winner.name} defeated ${loser.name}! (+${eloChanges.newWinnerElo - winnerElo} Elo)`
        });

        console.log("‚úÖ Sauvegarde r√©ussie!");
        showNotification(`${winner.name} wins! Elo: +${eloChanges.newWinnerElo - winnerElo}`, 'success');
    } catch (error) {
        console.error("‚ùå Erreur de sauvegarde:", error);
        showNotification("Error saving match result: " + error.message, 'error');
    }
}
    // Recherchez la fonction setMatchWinner (~ligne 450)
// APR√àS cette fonction, ajoutez :

// ============================================================
// NOUVELLE FONCTION: ARCHIVER LE ROUND ACTUEL
// ============================================================
async function archiveCurrentRound() {
    if (!state.activeTournament) {
        console.log("No active tournament to archive");
        return;
    }
    
    const currentRound = state.activeTournament.round;
    const matchesThisRound = state.activeTournament.matches.filter(m => m.round === currentRound);
    
    if (matchesThisRound.length === 0) {
        console.log("No matches in current round to archive");
        return;
    }
    
    console.log(`Archiving round ${currentRound} with ${matchesThisRound.length} matches`);
    
    const roundData = {
    id: `round_${state.activeTournament.id}_${currentRound}_${Date.now()}`,
    tournamentId: state.activeTournament.id, // <-- CORRIG√â
    tournamentName: state.activeTournament.name,
        roundNumber: currentRound,
        date: new Date().toISOString(),
        timestamp: Date.now(),
        matches: matchesThisRound.map(match => ({
            matchId: match.id,
            player1: {
                id: match.player1.id,
                name: match.player1.name,
                rank: match.player1.rank,
                playedBlack: match.player1IsBlack,
                elo: state.eloRatings[match.player1.id] || state.systemSettings.initialElo
            },
            player2: {
                id: match.player2.id,
                name: match.player2.name,
                rank: match.player2.rank,
                playedBlack: !match.player1IsBlack,
                elo: state.eloRatings[match.player2.id] || state.systemSettings.initialElo
            },
            winner: match.winner,
            winnerName: match.winner ? 
                (match.winner === match.player1.id ? match.player1.name : match.player2.name) : 
                null,
            gameLink: match.gameUrl,
            eloChanges: match.eloChanges || null,
            completedAt: match.endedAt || new Date().toISOString()
        })),
        standings: state.activeTournament.participants.map(p => {
            const wins = state.activeTournament.matches.filter(m => m.winner === p.id).length;
            return {
                id: p.id,
                name: p.name,
                rank: p.rank,
                wins: wins,
                losses: state.activeTournament.matches.filter(m => 
                    (m.player1.id === p.id || m.player2.id === p.id) && 
                    m.winner && 
                    m.winner !== p.id
                ).length,
                points: p.points || 0,
                elo: state.eloRatings[p.id] || state.systemSettings.initialElo
            };
        }).sort((a, b) => b.wins - a.wins),
        totalMatches: matchesThisRound.length,
        completedMatches: matchesThisRound.filter(m => m.winner).length
    };
    
    try {
        // Ajouter √† l'historique dans Firebase
        const updatedRoundHistory = [...(state.roundHistory || []), roundData];
        
        await updateDoc(systemRef, {
    roundHistory: updatedRoundHistory,
    lastAction: `üìÅ Round ${currentRound} archived with ${matchesThisRound.length} matches`
});
        
        console.log("Round archived successfully:", roundData);
        showNotification(`Round ${currentRound} archived successfully`, 'success');
        
        return roundData;
    } catch (error) {
        console.error("Error archiving round:", error);
        showNotification("Error archiving round", 'error');
        return null;
    }
}

function debugRoundArchiving() {
    console.log("üîç Debug Round Archiving:");
    console.log("Active Tournament:", state.activeTournament);
    console.log("Current Round:", state.activeTournament?.round);
    console.log("Matches this round:", state.activeTournament?.matches?.filter(m => m.round === state.activeTournament.round)?.length || 0);
    console.log("Round History:", state.roundHistory);
    
    if (state.activeTournament) {
        const currentRound = state.activeTournament.round;
        const matches = state.activeTournament.matches.filter(m => m.round === currentRound);
        console.log("Matches details:", matches.map(m => ({
            id: m.id,
            players: `${m.player1.name} vs ${m.player2.name}`,
            winner: m.winner,
            gameUrl: m.gameUrl
        })));
    }
}
    async function endTournament() {
    if (!isAdmin) {
        showNotification('Admin access required', 'error');
        return;
    }

    if (!confirm('End this tournament and update rankings?')) {
        return;
    }

    // Archiver le dernier round
    try {
        await archiveCurrentRound();
    } catch (error) {
        console.error("Failed to archive final round:", error);
    }

    let updatedTournamentCount = state.tournamentCount + 1;
    let updatedSeason = state.season;
    let updatedChampion = state.champion;
    
    // Calculate tournament results with rewards
    const tournamentResults = state.activeTournament.participants.map(p => {
        const wins = state.activeTournament.matches.filter(m => m.winner === p.id).length;
        const losses = state.activeTournament.matches.filter(m => 
            (m.player1.id === p.id || m.player2.id === p.id) && 
            m.winner && 
            m.winner !== p.id
        ).length;
        return { 
            ...p, 
            tournamentWins: wins,
            tournamentLosses: losses,
            tournamentPoints: wins * state.activeTournament.settings.pointsPerWin + 
                            losses * state.activeTournament.settings.pointsPerLoss
        };
    }).sort((a, b) => b.tournamentPoints - a.tournamentPoints);

    state.roundHistory.filter(r => r.tournamentId === state.activeTournament.id)
// Pas : r.tourneyId

    // ‚≠ê‚≠ê AJOUT: V√©rifier si c'est le dernier tournoi de la saison ‚≠ê‚≠ê
    const isSeasonFinale = (updatedTournamentCount % 4 === 0);
    const tournamentPositionInSeason = (state.tournamentCount % 4) + 1;
    
    // ‚≠ê‚≠ê AJOUT: Pr√©parer les r√©compenses ‚≠ê‚≠ê
    let rewards = null;
    if (isSeasonFinale && tournamentResults.length >= 3) {
        rewards = {
            champion: {
                player: tournamentResults[0],
                reward: SEASON_REWARDS[1]
            },
            runnerUp: {
                player: tournamentResults[1],
                reward: SEASON_REWARDS[2]
            },
            thirdPlace: {
                player: tournamentResults[2],
                reward: SEASON_REWARDS[3]
            }
        };
        
        // Notification sp√©ciale pour les r√©compenses
        showNotification(
            `üèÜ SEASON FINALE COMPLETE!\n` +
            `ü•á ${tournamentResults[0].name}: ${SEASON_REWARDS[1]}\n` +
            `ü•à ${tournamentResults[1].name}: ${SEASON_REWARDS[2]}\n` +
            `ü•â ${tournamentResults[2].name}: ${SEASON_REWARDS[3]}`,
            'success'
        );
    }

    // R√©cup√©rer les rounds du tournoi
    const tournamentRounds = state.roundHistory ? 
        state.roundHistory.filter(r => r.tournamentId === state.activeTournament.id) : 
        [];
    
    const remainingRoundHistory = state.roundHistory ? 
        state.roundHistory.filter(r => r.tournamentId !== state.activeTournament.id) : 
        [];

    // Add tournament to history WITH ROUNDS AND REWARDS
    const tournamentRecord = {
        ...state.activeTournament,
        endTime: new Date().toISOString(),
        results: tournamentResults.map(r => ({
            playerId: r.id,
            playerName: r.name,
            wins: r.tournamentWins,
            losses: r.tournamentLosses,
            points: r.tournamentPoints
        })),
        winner: tournamentResults[0]?.id || null,
        season: state.season,
        positionInSeason: tournamentPositionInSeason,
        rounds: tournamentRounds,
        totalRoundsArchived: tournamentRounds.length,
        // ‚≠ê‚≠ê AJOUT: Ajouter les r√©compenses au record ‚≠ê‚≠ê
        isSeasonFinale: isSeasonFinale,
        rewards: rewards,
        podium: rewards ? [
            { position: 1, player: tournamentResults[0].name, reward: SEASON_REWARDS[1] },
            { position: 2, player: tournamentResults[1].name, reward: SEASON_REWARDS[2] },
            { position: 3, player: tournamentResults[2].name, reward: SEASON_REWARDS[3] }
        ] : null
    };

    // Check if season is complete (4 tournaments)
    if (isSeasonFinale) {
        updatedSeason += 1;
        
        if (tournamentResults.length > 0 && tournamentResults[0].tournamentWins > 0) {
            updatedChampion = tournamentResults[0].name;
        }
        
        const seasonRecord = {
            season: state.season,
            tournaments: state.tournamentHistory.slice(-3).concat([tournamentRecord]),
            champion: updatedChampion,
            endDate: new Date().toISOString(),
            // ‚≠ê‚≠ê AJOUT: R√©compenses dans le record de saison ‚≠ê‚≠ê
            rewardsDistributed: rewards !== null,
            podium: tournamentRecord.podium
        };
        
        const updatedSeasonHistory = [...state.seasonHistory, seasonRecord];
        
        try {
            await updateDoc(systemRef, {
    activeTournament: null,
    tournamentHistory: [...state.tournamentHistory, tournamentRecord],
    tournamentCount: updatedTournamentCount,
    season: updatedSeason,
    champion: updatedChampion,
    autoQualifiers: [],
    seasonHistory: updatedSeasonHistory,
    roundHistory: remainingRoundHistory,
    lastAction: `üèÜ Season ${state.season} complete! ${updatedChampion} is the new champion!`
});
            
            // ‚≠ê‚≠ê AJOUT: Notification d√©taill√©e des r√©compenses ‚≠ê‚≠ê
            if (rewards) {
                setTimeout(() => {
                    showNotification(
                        `üéâ SEASON ${state.season} REWARDS DISTRIBUTED!\n\n` +
                        `ü•á ${tournamentResults[0].name}: ${SEASON_REWARDS[1]}\n` +
                        `ü•à ${tournamentResults[1].name}: ${SEASON_REWARDS[2]}\n` +
                        `ü•â ${tournamentResults[2].name}: ${SEASON_REWARDS[3]}`,
                        'success',
                        10000 // 10 secondes
                    );
                }, 2000);
            }
            
        } catch (error) {
            console.error("Firebase update error:", error);
            showNotification("Error saving tournament data", 'error');
        }
        
    } else {
        try {
            await updateDoc(systemRef, {
    activeTournament: null,
    tournamentHistory: [...state.tournamentHistory, tournamentRecord],
    tournamentCount: updatedTournamentCount,
    champion: updatedChampion,
    roundHistory: remainingRoundHistory,
    lastAction: `üèÅ Tournament "${state.activeTournament.name}" ended`
});
            
            showNotification('Tournament ended successfully', 'success');
        } catch (error) {
            console.error("Firebase update error:", error);
            showNotification("Error saving tournament data", 'error');
        }
    }
}

// Ajoutez cette fonction et appelez-la depuis la console
function debugRoundHistory() {
    console.log("üìä DEBUG Round History:");
    console.log("Total rounds archived:", state.roundHistory?.length || 0);
    
    if (state.roundHistory && state.roundHistory.length > 0) {
        state.roundHistory.forEach((round, index) => {
            console.log(`Round ${index + 1}:`, {
                id: round.id,
                tournamentId: round.tournamentId || round.tourneyId,
                tournamentName: round.tournamentName,
                roundNumber: round.roundNumber,
                date: round.date,
                matches: round.matches?.length || 0
            });
        });
    } else {
        console.log("‚ùå No rounds in roundHistory");
    }
    
    // V√©rifiez aussi dans tournamentHistory
    console.log("üìä DEBUG Tournament History:");
    console.log("Total tournaments:", state.tournamentHistory?.length || 0);
    
    if (state.tournamentHistory && state.tournamentHistory.length > 0) {
        state.tournamentHistory.forEach((tournament, index) => {
            console.log(`Tournament ${index + 1}: "${tournament.name}"`, {
                id: tournament.id,
                rounds: tournament.rounds?.length || 0,
                matches: tournament.matches?.length || 0
            });
        });
    }
}


async function recoverLostRounds() {
    if (!isAdmin) {
        showNotification('Admin access required', 'error');
        return;
    }
    
    if (!confirm('This will attempt to recover lost rounds from existing matches. Continue?')) {
        return;
    }
    
    console.log("üîÑ Attempting to recover lost rounds...");
    
    // V√©rifiez d'abord si vous avez un tournoi actif avec des matchs
    if (!state.activeTournament || !state.activeTournament.matches || state.activeTournament.matches.length === 0) {
        showNotification('No active tournament with matches found', 'error');
        return;
    }
    
    // Group matches by round
    const matchesByRound = {};
    state.activeTournament.matches.forEach(match => {
        const round = match.round || 1;
        if (!matchesByRound[round]) {
            matchesByRound[round] = [];
        }
        matchesByRound[round].push(match);
    });
    
    console.log("Matches grouped by round:", matchesByRound);
    
    // Create round objects for each round with matches
    const recoveredRounds = [];
    
    Object.keys(matchesByRound).sort((a, b) => a - b).forEach(roundNum => {
        const roundMatches = matchesByRound[roundNum];
        const completedMatches = roundMatches.filter(m => m.winner).length;
        
        const roundData = {
            id: `recovered_${state.activeTournament.id}_${roundNum}_${Date.now()}`,
            tournamentId: state.activeTournament.id,
            tournamentName: state.activeTournament.name,
            roundNumber: parseInt(roundNum),
            date: new Date().toISOString(),
            timestamp: Date.now(),
            matches: roundMatches.map(match => ({
                matchId: match.id,
                player1: {
                    id: match.player1.id,
                    name: match.player1.name,
                    rank: match.player1.rank,
                    playedBlack: match.player1IsBlack,
                    elo: state.eloRatings[match.player1.id] || state.systemSettings.initialElo
                },
                player2: {
                    id: match.player2.id,
                    name: match.player2.name,
                    rank: match.player2.rank,
                    playedBlack: !match.player1IsBlack,
                    elo: state.eloRatings[match.player2.id] || state.systemSettings.initialElo
                },
                winner: match.winner,
                winnerName: match.winner ? 
                    (match.winner === match.player1.id ? match.player1.name : match.player2.name) : 
                    null,
                gameLink: match.gameUrl,
                eloChanges: match.eloChanges || null,
                completedAt: match.endedAt || new Date().toISOString()
            })),
            totalMatches: roundMatches.length,
            completedMatches: completedMatches
        };
        
        recoveredRounds.push(roundData);
        
        console.log(`Recovered round ${roundNum}:`, {
            matches: roundMatches.length,
            completed: completedMatches
        });
    });
    
    // Check if we already have these rounds in roundHistory
    const existingRoundIds = new Set((state.roundHistory || []).map(r => `${r.tournamentId}_${r.roundNumber}`));
    const newRounds = recoveredRounds.filter(r => 
        !existingRoundIds.has(`${r.tournamentId}_${r.roundNumber}`)
    );
    
    if (newRounds.length === 0) {
        showNotification('No new rounds to recover (all rounds already archived)', 'info');
        return;
    }
    
    // Add to roundHistory
    const updatedRoundHistory = [...(state.roundHistory || []), ...newRounds];
    
    try {
        // Also update the tournament with rounds
        const tournamentIndex = state.tournamentHistory.findIndex(t => t.id === state.activeTournament.id);
        let updatedTournamentHistory = [...state.tournamentHistory];
        
        if (tournamentIndex !== -1) {
            const tournament = updatedTournamentHistory[tournamentIndex];
            updatedTournamentHistory[tournamentIndex] = {
                ...tournament,
                rounds: [...(tournament.rounds || []), ...newRounds]
            };
        }
        
        // Save to Firebase
        await updateDoc(systemRef, {
            roundHistory: updatedRoundHistory,
            tournamentHistory: updatedTournamentHistory,
            lastAction: `üîç Recovered ${newRounds.length} lost rounds`
        });
        
        showNotification(`‚úÖ Recovered ${newRounds.length} rounds with ${recoveredRounds.reduce((sum, r) => sum + r.matches.length, 0)} matches`, 'success');
        
        console.log("Recovered rounds details:", newRounds);
        
    } catch (error) {
        console.error("Error recovering rounds:", error);
        showNotification("Error: " + error.message, 'error');
    }
}

// Exposez la fonction
window.recoverLostRounds = recoverLostRounds;

async function manuallyArchiveCurrentRound() {
    if (!isAdmin) {
        showNotification('Admin access required', 'error');
        return;
    }
    
    if (!state.activeTournament) {
        showNotification('No active tournament', 'error');
        return;
    }
    
    const currentRound = state.activeTournament.round;
    const matchesThisRound = state.activeTournament.matches.filter(m => m.round === currentRound);
    
    if (matchesThisRound.length === 0) {
        showNotification('No matches in current round to archive', 'warning');
        return;
    }
    
    const roundName = prompt('Enter a name for this archived round:', `Round ${currentRound} - ${state.activeTournament.name}`);
    if (!roundName) return;
    
    const roundData = {
        id: `manual_${state.activeTournament.id}_${currentRound}_${Date.now()}`,
        tournamentId: state.activeTournament.id,
        tournamentName: state.activeTournament.name,
        roundNumber: currentRound,
        roundName: roundName,
        date: new Date().toISOString(),
        timestamp: Date.now(),
        matches: matchesThisRound.map(match => ({
            matchId: match.id,
            player1: {
                id: match.player1.id,
                name: match.player1.name,
                rank: match.player1.rank,
                playedBlack: match.player1IsBlack,
                elo: state.eloRatings[match.player1.id] || state.systemSettings.initialElo
            },
            player2: {
                id: match.player2.id,
                name: match.player2.name,
                rank: match.player2.rank,
                playedBlack: !match.player1IsBlack,
                elo: state.eloRatings[match.player2.id] || state.systemSettings.initialElo
            },
            winner: match.winner,
            winnerName: match.winner ? 
                (match.winner === match.player1.id ? match.player1.name : match.player2.name) : 
                null,
            gameLink: match.gameUrl,
            eloChanges: match.eloChanges || null,
            completedAt: match.endedAt || new Date().toISOString()
        })),
        totalMatches: matchesThisRound.length,
        completedMatches: matchesThisRound.filter(m => m.winner).length,
        manuallyArchived: true
    };
    
    const updatedRoundHistory = [...(state.roundHistory || []), roundData];
    
    try {
        await updateDoc(systemRef, {
            roundHistory: updatedRoundHistory,
            lastAction: `üìÅ Manually archived round ${currentRound}: "${roundName}"`
        });
        
        showNotification(`‚úÖ Round ${currentRound} archived manually as "${roundName}"`, 'success');
        
        console.log("Manually archived round:", roundData);
        
    } catch (error) {
        console.error("Error manually archiving round:", error);
        showNotification("Error: " + error.message, 'error');
    }
}

window.manuallyArchiveCurrentRound = manuallyArchiveCurrentRound;

    // Generate Swiss Pairs
   async function generateSwissPairs() {
    if (!isAdmin || !state.activeTournament) {
        showNotification('Admin access required', 'error');
        return;
    }

    const participants = [...state.activeTournament.participants];
    const currentRound = state.activeTournament.round;
    const existingMatches = state.activeTournament.matches.filter(m => m.round === currentRound);
    
    if (existingMatches.length > 0) {
        if (!confirm(`${existingMatches.length} matches already exist for round ${currentRound}. Generate new pairs anyway?`)) {
            return;
        }
    }

    // 1. Calculer les scores actuels pour ce tournoi
    const playerStats = participants.map(player => {
        // Compter les victoires dans ce tournoi
        const winsInTournament = state.activeTournament.matches
            .filter(m => m.winner === player.id && m.round < currentRound)
            .length;
        
        // Compter les d√©faites dans ce tournoi
        const lossesInTournament = state.activeTournament.matches
            .filter(m => 
                (m.player1.id === player.id || m.player2.id === player.id) && 
                m.winner && 
                m.winner !== player.id &&
                m.round < currentRound
            ).length;
        
        // Liste des adversaires d√©j√† rencontr√©s (tableau, pas Set)
        const opponents = state.activeTournament.matches
            .filter(m => 
                (m.player1.id === player.id || m.player2.id === player.id) && 
                m.round < currentRound
            )
            .map(m => m.player1.id === player.id ? m.player2.id : m.player1.id);
        
        // Score bas√© sur les victoires (1 point par victoire)
        const score = winsInTournament;
        
        // Buchholz (somme des scores des adversaires)
        const opponentScores = opponents.map(opponentId => {
            const oppWins = state.activeTournament.matches
                .filter(m => m.winner === opponentId && m.round < currentRound)
                .length;
            return oppWins;
        });
        const buchholz = opponentScores.reduce((sum, s) => sum + s, 0);
        
        // Sonneborn-Berger (points contre les adversaires battus)
        const sonnebornBerger = opponents.reduce((total, opponentId, index) => {
            if (state.activeTournament.matches.some(m => 
                ((m.player1.id === player.id && m.player2.id === opponentId) ||
                 (m.player2.id === player.id && m.player1.id === opponentId)) &&
                m.winner === player.id
            )) {
                return total + opponentScores[index];
            }
            return total;
        }, 0);

        return {
            ...player,
            id: player.id,
            wins: winsInTournament,
            losses: lossesInTournament,
            score: score,
            buchholz: buchholz,
            sonnebornBerger: sonnebornBerger,
            opponents: opponents, // Tableau, pas Set (pour Firebase)
            elo: state.eloRatings[player.id] || state.systemSettings.initialElo,
            played: opponents.length
        };
    });

    // 2. Trier les joueurs selon le syst√®me suisse
    playerStats.sort((a, b) => {
        // 1. Par score (victoires)
        if (b.score !== a.score) return b.score - a.score;
        
        // 2. Par Buchholz
        if (b.buchholz !== a.buchholz) return b.buchholz - a.buchholz;
        
        // 3. Par Sonneborn-Berger
        if (b.sonnebornBerger !== a.sonnebornBerger) return b.sonnebornBerger - a.sonnebornBerger;
        
        // 4. Par Elo
        if (b.elo !== a.elo) return b.elo - a.elo;
        
        // 5. Par moins de parties jou√©es (pour √©viter les byes)
        return a.played - b.played;
    });

        // 3. G√©n√©rer les paires
    const newMatches = [];
    const paired = new Set();
    const playersToPair = [...playerStats];
    
    console.log("Players sorted for pairing:", playersToPair.map(p => ({
        name: p.name,
        score: p.score,
        buchholz: p.buchholz,
        elo: p.elo,
        opponents: p.opponents || []
    })));

    // Premier essai : pairing id√©al sans r√©p√©tition
    for (let i = 0; i < playersToPair.length; i++) {
        if (paired.has(playersToPair[i].id)) continue;
        
        let bestOpponentIndex = -1;
        let bestScoreDiff = Infinity;
        let bestEloDiff = Infinity;
        
        // Chercher le meilleur adversaire
        for (let j = i + 1; j < playersToPair.length; j++) {
            if (paired.has(playersToPair[j].id)) continue;
            
            // V√âRIFICATION AM√âLIOR√âE : Ne pas pairer si d√©j√† rencontr√© dans CE tournoi
            const alreadyPlayed = state.activeTournament.matches.some(m => 
                ((m.player1.id === playersToPair[i].id && m.player2.id === playersToPair[j].id) ||
                 (m.player2.id === playersToPair[i].id && m.player1.id === playersToPair[j].id)) &&
                m.round < currentRound
            );
            
            if (alreadyPlayed) {
                console.log(`‚ö†Ô∏è Skip: ${playersToPair[i].name} already played ${playersToPair[j].name}`);
                continue;
            }
            
            // Calculer la diff√©rence de score
            const scoreDiff = Math.abs(playersToPair[i].score - playersToPair[j].score);
            const eloDiff = Math.abs(playersToPair[i].elo - playersToPair[j].elo);
            
            // Priorit√© : m√™me score, puis Elo proche
            if (scoreDiff < bestScoreDiff || 
                (scoreDiff === bestScoreDiff && eloDiff < bestEloDiff)) {
                bestScoreDiff = scoreDiff;
                bestEloDiff = eloDiff;
                bestOpponentIndex = j;
            }
        }
        
        // Si on a trouv√© un adversaire
        if (bestOpponentIndex !== -1) {
            newMatches.push({
                id: Date.now() + Math.random(),
                player1: playersToPair[i],
                player2: playersToPair[bestOpponentIndex],
                winner: null,
                round: currentRound,
                player1IsBlack: Math.random() > 0.5,
                gameUrl: null,
                scoreDiff: Math.abs(playersToPair[i].score - playersToPair[bestOpponentIndex].score),
                eloDiff: Math.abs(playersToPair[i].elo - playersToPair[bestOpponentIndex].elo)
            });
            
            paired.add(playersToPair[i].id);
            paired.add(playersToPair[bestOpponentIndex].id);
            
            console.log(`‚úÖ Paired: ${playersToPair[i].name} (${playersToPair[i].score} pts) vs ${playersToPair[bestOpponentIndex].name} (${playersToPair[bestOpponentIndex].score} pts)`);
        }
    }
    
    // Deuxi√®me essai : pour les joueurs restants, assouplir les contraintes
    const remainingPlayers = playersToPair.filter(p => !paired.has(p.id));
    if (remainingPlayers.length > 0) {
        console.log("Remaining players after first pass:", remainingPlayers.map(p => p.name));
        
        // Essayer de pairer les restants m√™me si diff√©rence de score plus grande
        for (let i = 0; i < remainingPlayers.length - 1; i += 2) {
            const player1 = remainingPlayers[i];
            const player2 = remainingPlayers[i + 1];
            
            if (player2) {
                // V√©rifier quand m√™me si pas d√©j√† jou√© ensemble
                const alreadyPlayed = state.activeTournament.matches.some(m => 
                    ((m.player1.id === player1.id && m.player2.id === player2.id) ||
                     (m.player2.id === player1.id && m.player1.id === player2.id)) &&
                    m.round < currentRound
                );
                
                if (!alreadyPlayed) {
                    newMatches.push({
                        id: Date.now() + Math.random(),
                        player1: player1,
                        player2: player2,
                        winner: null,
                        round: currentRound,
                        player1IsBlack: Math.random() > 0.5,
                        gameUrl: null,
                        forcedPairing: true
                    });
                    
                    paired.add(player1.id);
                    paired.add(player2.id);
                    
                    console.log(`ü§ù Forced pairing: ${player1.name} vs ${player2.name}`);
                } else {
                    console.log(`‚ùå Cannot force pairing: ${player1.name} already played ${player2.name}`);
                    // Chercher un autre partenaire
                    for (let k = i + 2; k < remainingPlayers.length; k++) {
                        const alternatePlayer = remainingPlayers[k];
                        const altAlreadyPlayed = state.activeTournament.matches.some(m => 
                            ((m.player1.id === player1.id && m.player2.id === alternatePlayer.id) ||
                             (m.player2.id === player1.id && m.player1.id === alternatePlayer.id)) &&
                            m.round < currentRound
                        );
                        
                        if (!altAlreadyPlayed) {
                            newMatches.push({
                                id: Date.now() + Math.random(),
                                player1: player1,
                                player2: alternatePlayer,
                                winner: null,
                                round: currentRound,
                                player1IsBlack: Math.random() > 0.5,
                                gameUrl: null,
                                forcedPairing: true,
                                swapped: true
                            });
                            
                            paired.add(player1.id);
                            paired.add(alternatePlayer.id);
                            // R√©organiser la liste des joueurs restants
                            remainingPlayers.splice(k, 1);
                            remainingPlayers.splice(i + 1, 0, player2); // Remettre player2 dans la liste
                            
                            console.log(`üîÑ Swapped pairing: ${player1.name} vs ${alternatePlayer.name}`);
                            break;
                        }
                    }
                }
            }
        }
        
        // Si nombre impair de joueurs, le dernier a un bye
        if (remainingPlayers.length % 2 === 1) {
            const byePlayer = remainingPlayers[remainingPlayers.length - 1];
            showNotification(`${byePlayer.name} gets a BYE (no opponent available)`, 'warning');
            console.log(`üé≤ Bye for: ${byePlayer.name}`);
            
            // Ajouter un match fictif pour le bye
            newMatches.push({
                id: Date.now() + Math.random(),
                player1: byePlayer,
                player2: { id: 'bye', name: 'BYE', rank: 'N/A' },
                winner: byePlayer.id, // Victoire automatique
                round: currentRound,
                player1IsBlack: true,
                gameUrl: null,
                isBye: true
            });
            
            paired.add(byePlayer.id);
        }
    }

    // 4. Filtrer les anciens matchs de ce round et ajouter les nouveaux
    const filteredExistingMatches = state.activeTournament.matches.filter(m => m.round !== currentRound);
    const updatedMatches = [...filteredExistingMatches, ...newMatches];
    
    try {
        await updateDoc(systemRef, {
            "activeTournament.matches": updatedMatches,
            lastAction: `üé≤ Swiss pairs generated for round ${currentRound}: ${newMatches.length} matches`
        });

        // Mettre √† jour le round progress
        const roundProgress = state.activeTournament.roundProgress || [];
        const roundIndex = currentRound - 1;
        
        if (roundIndex >= 0 && roundIndex < roundProgress.length) {
            roundProgress[roundIndex] = {
                ...roundProgress[roundIndex],
                totalMatches: newMatches.filter(m => !m.isBye).length
            };
            
            await updateDoc(systemRef, {
                "activeTournament.roundProgress": roundProgress
            });
        }

        const normalMatches = newMatches.filter(m => !m.isBye);
        const byeMatches = newMatches.filter(m => m.isBye);
        
        let message = `Generated ${normalMatches.length} pairs for round ${currentRound}`;
        if (byeMatches.length > 0) {
            message += ` (1 BYE for ${byeMatches[0].player1.name})`;
        }
        
        showNotification(message, 'success');
        
        console.log("New matches generated:", newMatches.map(m => ({
            players: `${m.player1.name} vs ${m.player2.name}`,
            scoreDiff: m.scoreDiff,
            eloDiff: m.eloDiff,
            isBye: m.isBye
        })));
        
    } catch (error) {
        console.error("Error generating pairs:", error);
        showNotification("Error generating pairs: " + error.message, 'error');
    }
}
    async function clearCurrentMatches() {
    if (!isAdmin) {
        showNotification('Admin access required', 'error');
        return;
    }

    if (!state.activeTournament) {
        showNotification('No active tournament', 'error');
        return;
    }

    const currentRound = state.activeTournament.round;
    
    if (currentRound >= state.activeTournament.totalRounds) {
        showNotification('Tournament has reached maximum rounds', 'warning');
        return;
    }

    if (!confirm(`Start round ${currentRound + 1}? This will archive round ${currentRound} and clear its matches.`)) {
        return;
    }

    try {
        // 1. ARCHIVER le round actuel
        const archivedRound = await archiveCurrentRound();
        
        if (!archivedRound) {
            showNotification('Failed to archive round', 'error');
            return;
        }
        
        // 2. Passer au round suivant
        const nextRound = currentRound + 1;
        
        // 3. Supprimer les matchs du round actuel
        const updatedMatches = state.activeTournament.matches.filter(m => m.round !== currentRound);
        
        // 4. Mettre √† jour le round dans le tournoi
        const updatedTournament = {
            ...state.activeTournament,
            round: nextRound,
            matches: updatedMatches
        };
        
        // Utiliser updateDoc au lieu de systemRef.update
        await updateDoc(systemRef, {
            "activeTournament": updatedTournament,
            lastAction: `üìä Round ${currentRound} archived ‚Üí Starting round ${nextRound}`
        });
        
        showNotification(`‚úÖ Round ${currentRound} archived ‚Üí Round ${nextRound} started`, 'success');
        
    } catch (error) {
        console.error("Error in clearCurrentMatches:", error);
        showNotification("Error: " + error.message, 'error');
    }
}

// Fonction pour v√©rifier si deux joueurs se sont d√©j√† rencontr√©s
function havePlayersPlayed(player1Id, player2Id, tournamentId = null) {
    // Si un tournoi sp√©cifique est fourni, v√©rifier seulement dans ce tournoi
    if (tournamentId) {
        const tournament = state.activeTournament?.id === tournamentId 
            ? state.activeTournament 
            : state.tournamentHistory.find(t => t.id === tournamentId);
        
        if (tournament) {
            return tournament.matches?.some(match => 
                (match.player1.id === player1Id && match.player2.id === player2Id) ||
                (match.player2.id === player1Id && match.player1.id === player2Id)
            ) || false;
        }
        return false;
    }
    
    // Sinon v√©rifier dans tous les tournois
    let allMatches = [];
    
    if (state.activeTournament) {
        allMatches = [...state.activeTournament.matches];
    }
    
    state.tournamentHistory.forEach(t => {
        if (t.matches) {
            allMatches = [...allMatches, ...t.matches];
        }
    });
    
    return allMatches.some(match => 
        (match.player1.id === player1Id && match.player2.id === player2Id) ||
        (match.player2.id === player1Id && match.player1.id === player2Id)
    );
}

function checkDuplicateMatches() {
    console.log("üîç V√©rification des matchs r√©p√©t√©s:");
    
    if (!state.activeTournament) {
        console.log("‚ùå Pas de tournoi actif");
        return;
    }
    
    const matches = state.activeTournament.matches;
    const duplicatePairs = new Map();
    
    for (let i = 0; i < matches.length; i++) {
        for (let j = i + 1; j < matches.length; j++) {
            const m1 = matches[i];
            const m2 = matches[j];
            
            const samePair = 
                (m1.player1.id === m2.player1.id && m1.player2.id === m2.player2.id) ||
                (m1.player1.id === m2.player2.id && m1.player2.id === m2.player1.id);
            
            if (samePair) {
                const key = [m1.player1.id, m1.player2.id].sort().join('_');
                if (!duplicatePairs.has(key)) {
                    duplicatePairs.set(key, []);
                }
                duplicatePairs.get(key).push({match1: m1, match2: m2});
            }
        }
    }
    
    if (duplicatePairs.size === 0) {
        console.log("‚úÖ Aucun match r√©p√©t√© trouv√©");
    } else {
        console.log(`‚ö†Ô∏è ${duplicatePairs.size} paires r√©p√©t√©es trouv√©es:`);
        duplicatePairs.forEach((matches, key) => {
            console.log(`- ${matches[0].match1.player1.name} vs ${matches[0].match1.player2.name}`);
            matches.forEach(m => {
                console.log(`  Round ${m.match1.round} (ID: ${m.match1.id}) et Round ${m.match2.round} (ID: ${m.match2.id})`);
            });
        });
    }
    
    return duplicatePairs.size;
}

// Exposez-la globalement
window.checkDuplicateMatches = checkDuplicateMatches;

    // Mise √† jour de l'interface utilisateur
  function updateUI() {
    updateRankings();
    updateTournamentView();
    updateStatistics();
    updateRecentMatches();
    updateSeasonTimeline();
    updateRoundProgress();
    if (chart) chart.destroy();
    renderChart();
    updateSeasonInfo();
    if (isAdmin) {
        updateEditMatchSelect();
    }
    // AJOUTEZ CETTE LIGNE :
    updateRoundsArchive();  // Mettre √† jour l'affichage des rounds archiv√©s
}


    function updateEditMatchSelect() {
        if (!state.activeTournament) return;
        
        const matchSelect = document.getElementById('editMatchSelect');
        if (!matchSelect) return;
        
        const currentRound = state.activeTournament.round;
        const matchesThisRound = state.activeTournament.matches.filter(m => m.round === currentRound);
        
        matchSelect.innerHTML = '<option value="">Select match to edit...</option>';
        matchesThisRound.forEach(match => {
            const option = document.createElement('option');
            option.value = match.id;
            option.textContent = `${match.player1.name} vs ${match.player2.name}`;
            matchSelect.appendChild(option);
        });
    }

  // Version simplifi√©e de updateRoundsArchive - √† remplacer compl√®tement
function updateRoundsArchive() {
    console.log("üìÅ UPDATE ROUNDS ARCHIVE - SIMPLE VERSION");
    
    const archiveList = document.getElementById('roundsArchiveList');
    if (!archiveList) {
        console.error("‚ùå Element 'roundsArchiveList' not found");
        return;
    }
    
    // V√©rification des donn√©es
    if (!state.roundHistory || state.roundHistory.length === 0) {
        console.log("No round history found");
        archiveList.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üìÅ</div>
                <h3>No rounds archived yet</h3>
                <p>Complete a round to see archived matches here</p>
            </div>
        `;
        return;
    }
    
    console.log(`Found ${state.roundHistory.length} rounds in history`);
    
    // ID du tournoi actuel et round actuel
    const currentTournamentId = state.activeTournament?.id;
    const currentRound = state.activeTournament?.round;
    
    // Filtrer pour EXCLURE le round actuel
    const archivedRounds = state.roundHistory.filter(round => {
        // Si c'est un round du tournoi actuel
        if (round.tournamentId === currentTournamentId) {
            const roundNum = round.roundNumber || round.round || 1;
            // Exclure le round actuel
            return roundNum !== currentRound;
        }
        // Garder tous les rounds d'autres tournois
        return true;
    });
    
    console.log(`Showing ${archivedRounds.length} archived rounds (current round ${currentRound} hidden)`);
    
    if (archivedRounds.length === 0) {
        archiveList.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üìÅ</div>
                <h3>No archived rounds available</h3>
                <p>Only current round (${currentRound}) is available</p>
            </div>
        `;
        return;
    }
    
    // Trier par date (plus r√©cent d'abord)
    const sortedRounds = [...archivedRounds].sort((a, b) => {
        const dateA = new Date(a.date || a.timestamp || 0);
        const dateB = new Date(b.date || b.timestamp || 0);
        return dateB - dateA;
    });
    
    // G√©n√©rer le HTML SIMPLE
    const roundsHTML = sortedRounds.map(round => {
        const roundNum = round.roundNumber || round.round || 1;
        const tournamentName = round.tournamentName || 'Unknown Tournament';
        const date = new Date(round.date || round.timestamp || Date.now());
        const formattedDate = date.toLocaleDateString('en-US', {
            day: '2-digit',
            month: 'short',
            hour: '2-digit',
            minute: '2-digit'
        });
        
        const matchCount = round.matches?.length || 0;
        const completedCount = round.completedMatches || 
            round.matches?.filter(m => m.winner).length || 0;
        
        return `
            <div class="history-item" style="cursor: pointer;" onclick="toggleRoundDetails('${round.id}')">
                <div class="history-header">
                    <div class="history-title">
                        <span style="color: var(--accent); font-weight: 700;">Round ${roundNum}</span>
                        ${tournamentName !== state.activeTournament?.name ? 
                          `<span style="margin-left: 10px; font-size: 0.8rem; color: var(--text-secondary);">(${tournamentName})</span>` : ''}
                    </div>
                    <div class="history-meta">${formattedDate}</div>
                </div>
                
                <div style="margin: 10px 0;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <div style="font-size: 0.9rem; color: var(--text-secondary);">
                                <span>üìä ${completedCount}/${matchCount} matches completed</span>
                            </div>
                            <div class="progress-bar" style="margin-top: 5px; height: 6px;">
                                <div class="progress-fill" style="width: ${matchCount > 0 ? Math.round((completedCount/matchCount)*100) : 0}%"></div>
                            </div>
                        </div>
                    </div>
                    
                    ${round.matches && round.matches.length > 0 ? `
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">
                            ${round.matches.slice(0, 2).map(match => {
                                const p1 = match.player1?.name || 'Player 1';
                                const p2 = match.player2?.name || 'Player 2';
                                return `<div style="margin: 3px 0; padding: 5px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                                    ${p1} vs ${p2} ${match.winner ? ' üèÜ' : ''}
                                </div>`;
                            }).join('')}
                            ${round.matches.length > 2 ? `<div style="margin-top: 5px; font-size: 0.8rem;">+ ${round.matches.length - 2} more matches</div>` : ''}
                        </div>
                    ` : ''}
                </div>
                
                <button class="history-expand-btn" onclick="event.stopPropagation(); toggleRoundDetails('${round.id}')">
                    üìä View Details
                </button>
            </div>
        `;
    }).join('');
    
    archiveList.innerHTML = roundsHTML;
    console.log(`‚úÖ ${archivedRounds.length} archived rounds displayed`);
}
// Ajoutez cette fonction apr√®s les autres fonctions de d√©bogage
function fixRoundsArchive() {
    console.log("üõ†Ô∏è Fixing Rounds Archive Display...");
    
    // Forcer l'affichage de tous les rounds
    const archiveList = document.getElementById('roundsArchiveList');
    if (!archiveList) return;
    
    if (!state.roundHistory || state.roundHistory.length === 0) {
        archiveList.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üìÅ</div>
                <h3>No rounds archived yet</h3>
                <p>Complete a round to see archived matches here</p>
            </div>
        `;
        return;
    }
    
    // Afficher TOUS les rounds sans filtrage
    const allRounds = state.roundHistory.slice().reverse();
    
    const roundsHTML = allRounds.map(round => {
        const roundNum = round.roundNumber || round.round || 1;
        const tournamentName = round.tournamentName || 'Unknown Tournament';
        const roundDate = new Date(round.date || round.timestamp || Date.now());
        const formattedDate = roundDate.toLocaleDateString('en-US', {
            day: '2-digit',
            month: 'short',
            hour: '2-digit',
            minute: '2-digit'
        });
        
        const totalMatches = round.matches?.length || 0;
        const completedMatches = round.completedMatches || 
            round.matches?.filter(m => m.winner).length || 0;
        
        return `
            <div class="history-item">
                <div class="history-header">
                    <div class="history-title">
                        <span style="color: var(--accent); font-weight: 700;">${tournamentName} - Round ${roundNum}</span>
                    </div>
                    <div class="history-meta">${formattedDate}</div>
                </div>
                
                <div style="margin: 10px 0;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div style="flex: 1;">
                            <div style="font-size: 0.9rem; color: var(--text-secondary);">
                                <span>üìä ${completedMatches}/${totalMatches} matches completed</span>
                            </div>
                        </div>
                    </div>
                    
                    ${round.matches && round.matches.length > 0 ? `
                        <div style="margin-top: 10px; font-size: 0.85rem;">
                            ${round.matches.slice(0, 3).map(match => `
                                <div style="margin: 5px 0; padding: 8px; background: rgba(255,255,255,0.05); border-radius: var(--radius-sm);">
                                    ${match.player1?.name || 'Player 1'} vs ${match.player2?.name || 'Player 2'}
                                    ${match.winner ? `<span style="color: var(--success); margin-left: 10px;">üèÜ Winner</span>` : ''}
                                </div>
                            `).join('')}
                            ${round.matches.length > 3 ? `<div style="color: var(--text-secondary); font-size: 0.8rem;">+ ${round.matches.length - 3} more matches</div>` : ''}
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    }).join('');
    
    archiveList.innerHTML = roundsHTML;
    
    // Mettre √† jour les compteurs
    document.getElementById('archivedRoundsCount').textContent = allRounds.length;
    document.getElementById('totalArchivedMatches').textContent = allRounds.reduce((sum, r) => sum + (r.matches?.length || 0), 0);
    
    console.log("‚úÖ Rounds Archive Fixed - Showing all rounds");
}

// Exposez-la globalement
window.fixRoundsArchive = fixRoundsArchive;
// Fonction pour afficher/masquer les d√©tails d'un round
function toggleRoundDetails(roundId) {
    const detailsDiv = document.getElementById(`roundDetails_${roundId}`);
    const button = event.target.closest('.history-item').querySelector('.history-expand-btn');
    
    if (detailsDiv.classList.contains('expanded')) {
        detailsDiv.classList.remove('expanded');
        button.innerHTML = 'üìä View Round Details';
    } else {
        detailsDiv.classList.add('expanded');
        button.innerHTML = 'üìä Hide Details';
    }
    
    // Emp√™cher la propagation pour √©viter de d√©clencher le onclick du parent
    event.stopPropagation();
}

// Fonction pour filtrer les rounds
function filterRounds(filterType) {
    document.querySelectorAll('#roundsFilters .history-filter').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    
    // Ici vous pourriez impl√©menter le filtrage si n√©cessaire
    showNotification(`Filtering rounds: ${filterType}`, 'info');
}

// Fonction pour exporter les donn√©es d'un round
async function exportRoundData(roundId) {
    const round = state.roundHistory.find(r => r.id === roundId);
    if (!round) {
        showNotification('Round not found', 'error');
        return;
    }
    
    const dataStr = JSON.stringify(round, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
    const exportFileName = `round-${round.tournamentName}-${round.roundNumber}-${new Date().toISOString().split('T')[0]}.json`;
    
    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileName);
    linkElement.click();
    
    showNotification(`Round ${round.roundNumber} data exported`, 'success');
}

// Fonction pour supprimer un round (admin only)
async function deleteRound(roundId) {
    if (!isAdmin || !confirm('Are you sure you want to delete this round? This action cannot be undone.')) {
        return;
    }
    
    const updatedRoundHistory = state.roundHistory.filter(r => r.id !== roundId);
    
    try {
        await updateDoc(systemRef, {
            roundHistory: updatedRoundHistory,
            lastAction: `üóëÔ∏è Round deleted from archive`
        });
        
        showNotification('Round deleted successfully', 'success');
        updateRoundsArchive();
        
    } catch (error) {
        console.error("Error deleting round:", error);
        showNotification("Error: " + error.message, 'error');
    }
}

    function updateRoundProgress() {
        const progressSection = document.getElementById('roundProgressSection');
        if (!progressSection) return;
        
        if (!state.activeTournament || !state.activeTournament.roundProgress || 
            !Array.isArray(state.activeTournament.roundProgress)) {
            progressSection.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">No progress available</div>';
            return;
        }
        
        const tournament = state.activeTournament;
        const html = tournament.roundProgress.map((round, index) => {
            const isCurrent = index + 1 === tournament.round;
            const progress = round.totalMatches > 0 ? (round.completedMatches / round.totalMatches) * 100 : 0;
            
            return `
                <div class="round-item ${isCurrent ? 'pulse' : ''}">
                    <div class="round-number" style="${isCurrent ? 'background: var(--accent);' : ''}">
                        ${index + 1}
                    </div>
                    <div class="round-info">
                        <div class="round-title">Round ${index + 1} ${isCurrent ? '(Current)' : ''}</div>
                        <div class="round-stats">
                            <span>${round.completedMatches || 0}/${round.totalMatches || 0} matches</span>
                            <span>${Math.round(progress)}% complete</span>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
        
        progressSection.innerHTML = html;
    }

   function updateMatchesDisplay() {
    console.log("üîÑ updateMatchesDisplay appel√©e, admin:", isAdmin);
    
    if (!state.activeTournament) {
        document.getElementById('matchesZone').innerHTML = '<div class="empty-state">No matches for this round yet</div>';
        return;
    }
    
    const currentRound = state.activeTournament.round;
    const matchesThisRound = state.activeTournament.matches.filter(m => m.round === currentRound);
    
    console.log("üìä Matchs ce round:", matchesThisRound.length);
    
    // TOUJOURS enlever guest-mode quand admin, mais il faut aussi v√©rifier la logique
    const container = document.querySelector('.container');
    if (container) {
        if (isAdmin) {
            container.classList.remove('guest-mode');
        } else {
            container.classList.add('guest-mode');
        }
    }
    
    const matchesHTML = matchesThisRound.map((match, index) => {
        const isCompleted = !!match.winner;
        const winnerIsPlayer1 = match.winner === match.player1.id;
        
        // D√âBUG: Afficher les informations du match
        console.log(`Match ${index}: ${match.player1.name} vs ${match.player2.name}, winner: ${match.winner}, isAdmin: ${isAdmin}`);
        
        return `
            <div class="match-card ${isCompleted ? 'completed' : ''}" data-match-id="${match.id}">
                <!-- JOUEUR 1 -->
                <div class="match-player ${winnerIsPlayer1 && isCompleted ? 'winner' : ''} ${!winnerIsPlayer1 && isCompleted ? 'loser' : ''}">
                    <!-- BOUTON SWAP COLORS - TOUJOURS VISIBLE SI ADMIN -->
                    ${isAdmin ? `
                        <button onclick="swapMatchColors('${match.id}')" class="swap-colors-btn" title="Swap colors" 
                                style="display: ${isAdmin ? 'flex' : 'none'} !important;">
                            ‚Üª
                        </button>
                    ` : ''}
                    
                    <div class="stone-display ${match.player1IsBlack ? 'black' : 'white'}"></div>
                    
                    <div class="player-label">${match.player1.name}</div>
                    <div class="player-subtext">${match.player1.rank} ‚Ä¢ ${state.eloRatings[match.player1.id] || 1500} Elo</div>
                    
                    <!-- BOUTON VICTOURE JOUEUR 1 - TOUJOURS VISIBLE SI ADMIN ET MATCH NON TERMIN√â -->
                    ${!isCompleted ? `
                        <button onclick="setMatchWinner('${match.id}', '${match.player1.id}')" 
                                class="win-btn" 
                                style="display: ${isAdmin ? 'block' : 'none'} !important; margin-top: 15px;">
                            üèÜ ${match.player1.name.split(' ')[0]} Wins
                        </button>
                    ` : ''}
                    
                    ${isCompleted ? (winnerIsPlayer1 ? 
                        '<div class="badge badge-success" style="margin-top: 15px;">üèÜ WINNER</div>' : 
                        '<div class="badge badge-danger" style="margin-top: 15px;">‚ùå DEFEATED</div>'
                    ) : ''}
                </div>
                
                <!-- CENTRE DU MATCH -->
                <div class="match-status">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--accent); margin-bottom: 20px;">VS</div>
                    
                    <!-- LIEN DE LA PARTIE - TOUJOURS VISIBLE SI ADMIN -->
                    <div style="text-align: center;">
                        ${match.gameUrl ? `
                            <a href="${match.gameUrl}" target="_blank" 
                               style="display: inline-block; padding: 10px 20px; background: var(--success); color: white; border-radius: 8px; text-decoration: none; font-weight: 600; margin-bottom: 10px;">
                                üîó GAME
                            </a>
                            ${isAdmin ? `
                                <div>
                                    <button onclick="promptGameLink('${match.id}')" 
                                            style="padding: 6px 12px; background: var(--warning); color: white; border: none; border-radius: 6px; cursor: pointer;">
                                        ‚úèÔ∏è Edit
                                    </button>
                                </div>
                            ` : ''}
                        ` : `
                            <button onclick="promptGameLink('${match.id}')" 
                                    style="display: ${isAdmin ? 'inline-block' : 'none'} !important;
                                           padding: 12px 24px; background: var(--secondary); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                                + Add link
                            </button>
                        `}
                    </div>
                    
                    <!-- Status du match -->
                    <div style="margin-top: 20px; font-size: 0.9rem; color: var(--text-secondary);">
                        ${isCompleted ? 
                            `<div style="color: var(--success); font-weight: 600;">‚úîÔ∏è Match completed</div>` : 
                            `<div style="color: var(--warning);">‚è≥ Match in progress</div>`
                        }
                    </div>
                </div>
                
                <!-- JOUEUR 2 -->
                <div class="match-player ${!winnerIsPlayer1 && isCompleted ? 'winner' : ''} ${winnerIsPlayer1 && isCompleted ? 'loser' : ''}">
                    <!-- BOUTON SWAP COLORS - TOUJOURS VISIBLE SI ADMIN -->
                    ${isAdmin ? `
                        <button onclick="swapMatchColors('${match.id}')" class="swap-colors-btn" title="Swap colors"
                                style="display: ${isAdmin ? 'flex' : 'none'} !important;">
                            ‚Üª
                        </button>
                    ` : ''}
                    
                    <div class="stone-display ${!match.player1IsBlack ? 'black' : 'white'}"></div>
                    
                    <div class="player-label">${match.player2.name}</div>
                    <div class="player-subtext">${match.player2.rank} ‚Ä¢ ${state.eloRatings[match.player2.id] || 1500} Elo</div>
                    
                    <!-- BOUTON VICTOURE JOUEUR 2 - TOUJOURS VISIBLE SI ADMIN ET MATCH NON TERMIN√â -->
                    ${!isCompleted ? `
                        <button onclick="setMatchWinner('${match.id}', '${match.player2.id}')" 
                                class="win-btn" 
                                style="display: ${isAdmin ? 'block' : 'none'} !important; margin-top: 15px;">
                            üèÜ ${match.player2.name.split(' ')[0]} Wins
                        </button>
                    ` : ''}
                    
                    ${isCompleted ? (!winnerIsPlayer1 ? 
                        '<div class="badge badge-success" style="margin-top: 15px;">üèÜ WINNER</div>' : 
                        '<div class="badge badge-danger" style="margin-top: 15px;">‚ùå DEFEATED</div>'
                    ) : ''}
                </div>
            </div>
        `;
    }).join('');
    
    document.getElementById('matchesZone').innerHTML = matchesHTML || 
        '<div class="empty-state">No matches for this round yet</div>';
    
    console.log("‚úÖ Affichage mis √† jour");
}
    function updateModeIndicator() {
    console.log("üéõÔ∏è updateModeIndicator, admin:", isAdmin);
    
    const headerControls = document.querySelector('.header-controls');
    if (!headerControls) return;
    
    let modeIndicator = document.getElementById('modeIndicator');
    
    if (!modeIndicator) {
        modeIndicator = document.createElement('div');
        modeIndicator.id = 'modeIndicator';
        modeIndicator.style.marginRight = '15px';
        headerControls.insertBefore(modeIndicator, headerControls.firstChild);
    }
    
    if (isAdmin) {
        modeIndicator.innerHTML = `
            <span style="font-weight: 600; color: var(--accent);">üîß Admin Mode</span>
            <span class="guest-badge" style="background: var(--accent);">Full Control</span>
        `;
        
        // FORCER la suppression de guest-mode
        document.querySelector('.container')?.classList.remove('guest-mode');
        
        // FORCER l'affichage de tous les √©l√©ments admin
        document.querySelectorAll('.admin-hidden').forEach(el => {
            el.classList.remove('admin-hidden');
        });
        
        // FORCER le rafra√Æchissement des matchs
        setTimeout(() => {
            if (state.activeTournament) {
                updateMatchesDisplay();
            }
        }, 100);
        
    } else {
        modeIndicator.innerHTML = `
            <span style="font-weight: 600; color: var(--text-secondary);">üëÅÔ∏è Guest Mode</span>
            <span class="guest-badge" style="background: var(--secondary);">View Only</span>
        `;
        
        document.querySelector('.container')?.classList.add('guest-mode');
    }
}

    function updateRankings() {
        const sortedPlayers = [...state.players].sort((a, b) => {
            if (a.elo !== undefined && b.elo !== undefined) {
                return b.elo - a.elo;
            }
            return (b.points || 0) - (a.points || 0);
        });
        
        const rankingsHTML = sortedPlayers.map((player, index) => {
            const elo = state.eloRatings[player.id] || state.systemSettings.initialElo;
            const winRate = player.wins + player.losses > 0 
                ? Math.round((player.wins / (player.wins + player.losses)) * 100) 
                : 0;
            
            return `
                <div class="player-item ${index < 3 ? 'top-3' : ''}">
                    <div class="player-rank">${index + 1}</div>
                    <div class="player-info">
                        <div class="player-name">
                            ${player.name}
                            ${index === 0 ? '<span class="badge badge-gold">ü•á</span>' : ''}
                            ${index === 1 ? '<span class="badge badge-silver">ü•à</span>' : ''}
                            ${index === 2 ? '<span class="badge badge-bronze">ü•â</span>' : ''}
                        </div>
                        <div class="player-meta">
                            <span class="player-tag">${player.rank}</span>
                            <span>Elo: ${elo}</span>
                            <span>${player.wins || 0}W ${player.losses || 0}L</span>
                        </div>
                    </div>
                    <div class="player-stats">
                        <div class="player-points">${player.points || 0} pts</div>
                        <div class="player-record">${winRate}% win rate</div>
                    </div>
                </div>
            `;
        }).join('');

        document.getElementById('rankingsList').innerHTML = rankingsHTML || 
            '<div class="empty-state">No players registered yet</div>';
    }

    function updateTournamentView() {
    const tournamentTypeIcon = document.getElementById('tournamentTypeIcon');
    const tournamentTypeText = document.getElementById('tournamentTypeText');
    
    if (state.activeTournament) {
        document.getElementById('activeTournamentCard').style.display = 'block';
        document.getElementById('tournamentSetupCard').style.display = 'none';
        
        document.getElementById('tournamentTitle').textContent = state.activeTournament.name;
        document.getElementById('currentRound').textContent = state.activeTournament.round;
        document.getElementById('totalRounds').textContent = state.activeTournament.totalRounds;
        document.getElementById('tournamentPlayerCount').textContent = state.activeTournament.participants.length;
        
        // D√âTECTION SI C'EST LE DERNIER TOURNOI DE LA SAISON
        const tournamentInSeason = (state.tournamentCount % 4) + 1;
        const isEliminationTournament = state.activeTournament.type === 'single-elimination';
        const isLastTournament = tournamentInSeason === 4;
        
        // Mettre √† jour le type de tournoi
        if (state.activeTournament.type === 'single-elimination') {
            tournamentTypeIcon.textContent = 'üèÜ';
            tournamentTypeText.textContent = 'Single Elimination';
        } else {
            tournamentTypeIcon.textContent = '‚ôüÔ∏è';
            tournamentTypeText.textContent = 'Swiss System';
        }
        
        // AFFICHER LES R√âCOMPENSES SI DERNIER TOURNOI
        if (isLastTournament) {
            // Mettre √† jour le titre avec badge
            document.getElementById('tournamentTitle').innerHTML = `
                ${state.activeTournament.name}
                <span class="rewards-badge" style="margin-left: 10px; font-size: 0.7rem; background: linear-gradient(135deg, var(--gold) 0%, #FFA500 100%);">
                    üéÅ LAST TOURNAMENT ‚Ä¢ REWARDS ACTIVE
                </span>
            `;
            
            // Afficher la banni√®re des r√©compenses
            document.getElementById('seasonRewardsBanner').style.display = 'block';
            
            // Mettre √† jour les textes des r√©compenses depuis la constante
            document.getElementById('reward1').textContent = SEASON_REWARDS[1];
            document.getElementById('reward2').textContent = SEASON_REWARDS[2];
            document.getElementById('reward3').textContent = SEASON_REWARDS[3];
            
            // Ajouter une info dans les m√©tadonn√©es
            document.getElementById('tournamentTypeBadge').innerHTML += 
                '<span style="margin-left: 10px; background: var(--gold); color: black; padding: 2px 8px; border-radius: 12px; font-size: 0.7rem; font-weight: bold;">üéÅ REWARDS</span>';
        } else {
            document.getElementById('seasonRewardsBanner').style.display = 'none';
        }
        
        if (isAdmin && state.activeTournament) {
            document.getElementById('roundsCount').value = state.activeTournament.totalRounds || 3;
            document.getElementById('pointsPerWin').value = state.activeTournament.settings?.pointsPerWin || 10;
            document.getElementById('pointsPerLoss').value = state.activeTournament.settings?.pointsPerLoss || -5;
        }
        
        const participants = state.activeTournament.participants || [];
        const playerOptions = participants.map(p => 
            `<option value="${p.id}">${p.name} (${p.rank}) - ${state.eloRatings[p.id] || state.systemSettings.initialElo} Elo</option>`
        ).join('');
        
        document.getElementById('player1Select').innerHTML = `<option value="">Select player 1</option>${playerOptions}`;
        document.getElementById('player2Select').innerHTML = `<option value="">Select player 2</option>${playerOptions}`;
        
        document.getElementById('forceWinnerSelect').innerHTML = `<option value="">Select winner (optional)</option>${playerOptions}`;
        
        updateMatchesDisplay();
    } else {
        document.getElementById('activeTournamentCard').style.display = 'none';
        document.getElementById('tournamentSetupCard').style.display = 'block';
        
        updateEnrollmentZone();
        
        const nextTournamentNum = (state.tournamentCount % 4) + 1;
        document.getElementById('nextTournamentNumber').textContent = nextTournamentNum;
        
        // Afficher si le prochain tournoi aura des r√©compenses
        if (nextTournamentNum === 4) {
            document.getElementById('tournamentSetupCard').innerHTML += `
                <div class="format-banner" style="margin-top: 20px; background: linear-gradient(135deg, rgba(255,215,0,0.1) 0%, transparent 100%);">
                    <div class="format-title">
                        <span>üéÅ Next Tournament: Last of Season!</span>
                    </div>
                    <div class="format-details">
                        <div class="format-item">ü•á 1st: ${SEASON_REWARDS[1]}</div>
                        <div class="format-item">ü•à 2nd: ${SEASON_REWARDS[2]}</div>
                        <div class="format-item">ü•â 3rd: ${SEASON_REWARDS[3]}</div>
                    </div>
                </div>
            `;
        }
    }

}
        const tournamentTypeIcon = document.getElementById('tournamentTypeIcon');
        const tournamentTypeText = document.getElementById('tournamentTypeText');
        
        if (state.activeTournament) {
            document.getElementById('activeTournamentCard').style.display = 'block';
            document.getElementById('tournamentSetupCard').style.display = 'none';
            
            document.getElementById('tournamentTitle').textContent = state.activeTournament.name;
            document.getElementById('currentRound').textContent = state.activeTournament.round;
            document.getElementById('totalRounds').textContent = state.activeTournament.totalRounds;
            document.getElementById('tournamentPlayerCount').textContent = state.activeTournament.participants.length;
            
            if (state.activeTournament.type === 'single-elimination') {
                tournamentTypeIcon.textContent = 'üèÜ';
                tournamentTypeText.textContent = 'Single Elimination';
            } else {
                tournamentTypeIcon.textContent = '‚ôüÔ∏è';
                tournamentTypeText.textContent = 'Swiss System';
            }
            
            if (isAdmin && state.activeTournament) {
                document.getElementById('roundsCount').value = state.activeTournament.totalRounds || 3;
                document.getElementById('pointsPerWin').value = state.activeTournament.settings?.pointsPerWin || 10;
                document.getElementById('pointsPerLoss').value = state.activeTournament.settings?.pointsPerLoss || -5;
            }
            
            const participants = state.activeTournament.participants || [];
            const playerOptions = participants.map(p => 
                `<option value="${p.id}">${p.name} (${p.rank}) - ${state.eloRatings[p.id] || state.systemSettings.initialElo} Elo</option>`
            ).join('');
            
            document.getElementById('player1Select').innerHTML = `<option value="">Select player 1</option>${playerOptions}`;
            document.getElementById('player2Select').innerHTML = `<option value="">Select player 2</option>${playerOptions}`;
            
            document.getElementById('forceWinnerSelect').innerHTML = `<option value="">Select winner (optional)</option>${playerOptions}`;
            
            updateMatchesDisplay();
        } else {
            document.getElementById('activeTournamentCard').style.display = 'none';
            document.getElementById('tournamentSetupCard').style.display = 'block';
            
            updateEnrollmentZone();
            
            const nextTournamentNum = (state.tournamentCount % 4) + 1;
            document.getElementById('nextTournamentNumber').textContent = nextTournamentNum;
        }

    function updateEnrollmentZone() {
        const playersHTML = state.players.map(player => `
            <label class="enrollment-item">
                <input type="checkbox" class="enroll-check" value="${player.id}" checked>
                <span style="font-weight: 600;">${player.name}</span>
                <span style="margin-left: auto; font-size: 0.9rem; color: var(--text-secondary);">
                    ${player.rank} ‚Ä¢ ${state.eloRatings[player.id] || state.systemSettings.initialElo} Elo
                </span>
            </label>
        `).join('');
        
        document.getElementById('enrollmentZone').innerHTML = playersHTML || 
            '<div class="empty-state">No players available</div>';
    }

    function updateTournamentHistory() {
    const tournamentHistoryHTML = state.tournamentHistory.slice().reverse().map((tournament, index) => {
        const date = new Date(tournament.startTime);
        const formattedDate = date.toLocaleDateString('en-US', { 
            month: 'short', 
            day: 'numeric',
            year: 'numeric'
        });
        
        const winner = tournament.results?.[0]?.playerName || 'N/A';
        
        // MODIFICATION ICI : Compter les matchs depuis les rounds archiv√©s
        let totalMatchesCount = 0;
        if (tournament.rounds && tournament.rounds.length > 0) {
            // Compter tous les matchs de tous les rounds
            totalMatchesCount = tournament.rounds.reduce((total, round) => {
                return total + (round.matches?.length || 0);
            }, 0);
        } else {
            // Fallback sur les anciens matchs
            totalMatchesCount = tournament.matches?.length || 0;
        }
        
        const participants = tournament.participants?.length || 0;
        
        return `
            <div class="history-item ${tournament.isSeasonFinale ? 'season-finale' : ''}">
                <div class="history-header">
                    <div class="history-title">
                        ${tournament.name}
                        ${tournament.isSeasonFinale ? ' üèÜ' : ''}
                    </div>
                    <div class="history-meta">${formattedDate}</div>
                </div>
                <div style="color: var(--text-secondary); font-size: 0.9rem; margin: 10px 0;">
                    Season ${tournament.season || 1} ‚Ä¢ Tournament ${tournament.positionInSeason || 1}/4 ‚Ä¢ 
                    <span class="${tournament.type === 'single-elimination' ? 'match-status-badge match-status-completed' : 'match-status-badge match-status-pending'}" 
                          style="font-size: 0.7rem; padding: 2px 8px;">
                        ${tournament.type === 'single-elimination' ? 'üèÜ Elimination' : '‚ôüÔ∏è Swiss'}
                    </span>
                    ${tournament.isSeasonFinale ? 
                        '<span style="margin-left: 10px; background: var(--gold); color: black; padding: 2px 8px; border-radius: 12px; font-size: 0.7rem; font-weight: bold;">SEASON FINALE</span>' : 
                        ''
                    }
                </div>
                
                ${tournament.rewards ? `
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.1) 0%, rgba(255,215,0,0.05) 100%); 
                                border-radius: var(--radius-md); padding: 12px; margin: 10px 0; border-left: 3px solid var(--gold);">
                        <div style="font-weight: 600; color: var(--gold); margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                            üèÖ Season Rewards Distributed
                        </div>
                        <div style="font-size: 0.85rem;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                                <div style="width: 20px; height: 20px; background: var(--gold); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold;">1</div>
                                <span>${tournament.podium[0].player}: <strong>${tournament.podium[0].reward}</strong></span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                                <div style="width: 20px; height: 20px; background: var(--silver); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold;">2</div>
                                <span>${tournament.podium[1].player}: <strong>${tournament.podium[1].reward}</strong></span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div style="width: 20px; height: 20px; background: var(--bronze); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold;">3</div>
                                <span>${tournament.podium[2].player}: <strong>${tournament.podium[2].reward}</strong></span>
                            </div>
                        </div>
                    </div>
                ` : ''}
                
                <!-- NOUVEAU : Bouton pour voir les rounds archiv√©s -->
                ${tournament.rounds && tournament.rounds.length > 0 ? `
                    <div style="margin-top: 15px;">
                        <button onclick="toggleTournamentRounds('${tournament.id}')" 
                                class="history-expand-btn" 
                                style="margin-bottom: 10px;">
                            üìä View Rounds (${tournament.rounds.length})
                        </button>
                        
                        <div id="rounds_${tournament.id}" style="display: none;">
                            ${displayTournamentRoundsDetails(tournament.rounds)}
                        </div>
                    </div>
                ` : `
                    <div style="margin-top: 15px; color: var(--text-secondary); font-size: 0.9rem;">
                        ‚ö†Ô∏è No rounds archived for this tournament
                    </div>
                `}
                
                <div class="history-stats">
                    <div class="history-stat">
                        <span>üë• ${participants} players</span>
                    </div>
                    <div class="history-stat">
                        <span>‚öîÔ∏è ${totalMatchesCount} matches</span>  <!-- MODIFI√â ICI -->
                    </div>
                    <div class="history-stat">
                        <span>üèÜ ${winner}</span>
                    </div>
                </div>
                
                <!-- Bouton pour voir les d√©tails (optionnel) -->
                <button onclick="toggleHistoryDetails(${index})" class="history-expand-btn">
                    üìä View Details
                </button>
                
                <div class="history-details" id="historyDetails${index}">
                    <!-- Les d√©tails existants restent ici -->
                </div>
            </div>
        `;
    }).join('');
    
    document.getElementById('tournamentHistoryList').innerHTML = tournamentHistoryHTML;
}
    function toggleHistoryDetails(index) {
        const detailsDiv = document.getElementById(`historyDetails${index}`);
        detailsDiv.classList.toggle('expanded');
        
        const button = event.target;
        if (detailsDiv.classList.contains('expanded')) {
            button.innerHTML = 'üìä Hide Details';
        } else {
            button.innerHTML = 'üìä View Details';
        }
    }

    function debugTournamentData(tournamentId = null) {
    console.log("üîç DEBUG Tournament Data:");
    
    if (tournamentId) {
        const tournament = state.tournamentHistory.find(t => t.id === tournamentId);
        if (tournament) {
            console.log("Tournament:", tournament.name);
            console.log("Matches in tournament.matches:", tournament.matches?.length || 0);
            console.log("Rounds archived:", tournament.rounds?.length || 0);
            console.log("Total matches in rounds:", tournament.rounds?.reduce((sum, r) => sum + (r.matches?.length || 0), 0) || 0);
            console.log("Round details:", tournament.rounds);
        } else {
            console.log("Tournament not found");
        }
    } else {
        console.log("All tournaments:", state.tournamentHistory.map(t => ({
            name: t.name,
            matches: t.matches?.length || 0,
            rounds: t.rounds?.length || 0,
            totalMatchesInRounds: t.rounds?.reduce((sum, r) => sum + (r.matches?.length || 0), 0) || 0
        })));
    }
}

function testSeasonRewards() {
    console.log("üéÅ Season Rewards Test:");
    console.log("1st place:", SEASON_REWARDS[1]);
    console.log("2nd place:", SEASON_REWARDS[2]);
    console.log("3rd place:", SEASON_REWARDS[3]);
    
    // Test d'affichage
    return `
        <div style="padding: 10px; background: var(--bg-light); border-radius: 8px; margin: 10px 0;">
            <h3>Test des r√©compenses</h3>
            <p>ü•á ${SEASON_REWARDS[1]}</p>
            <p>ü•à ${SEASON_REWARDS[2]}</p>
            <p>ü•â ${SEASON_REWARDS[3]}</p>
        </div>
    `;
}

// Exposez-la pour tester
window.testSeasonRewards = testSeasonRewards;

    function updateSeasonTimeline() {
    const tournamentInSeason = (state.tournamentCount % 4) + 1;
    
    const seasonTimelineHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            ${[1, 2, 3, 4].map(num => `
                <div style="text-align: center; flex: 1;">
                    <div style="width: 40px; height: 40px; margin: 0 auto 10px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
                        background: ${num === tournamentInSeason ? 'var(--accent)' : num < tournamentInSeason ? 'var(--success)' : 'var(--secondary)'};
                        color: white; font-weight: 600;
                        ${num === 4 ? 'border: 2px solid var(--gold); box-shadow: 0 0 10px rgba(255,215,0,0.3);' : ''}">
                        ${num}
                        ${num === 4 ? 'üéÅ' : ''}
                    </div>
                    <div style="font-size: 0.8rem; color: var(--text-secondary);">
                        ${num === 4 ? '<strong style="color: var(--gold);">Last Tournament</strong><br>Elimination + Rewards' : 
                          num === 3 ? 'Swiss<br>Qualifiers' : 'Swiss'}
                    </div>
                </div>
            `).join('')}
        </div>
        
        ${tournamentInSeason === 4 ? `
            <div style="background: linear-gradient(135deg, rgba(255,215,0,0.1) 0%, transparent 100%); 
                        border-radius: var(--radius-md); padding: 12px; margin-top: 15px; border-left: 3px solid var(--gold);">
                <div style="font-weight: 600; color: var(--gold); margin-bottom: 5px;">
                    üéÅ Last Tournament Rewards Active!
                </div>
                <div style="font-size: 0.85rem; color: var(--text-secondary);">
                    This tournament includes special prizes for top 3 players
                </div>
            </div>
        ` : ''}
    `;
    
    document.getElementById('seasonTimeline').innerHTML = seasonTimelineHTML;
    
    const seasonProgress = (tournamentInSeason / 4) * 100;
    document.getElementById('seasonProgressText').textContent = `${tournamentInSeason}/4`;
    document.getElementById('seasonProgressFill').style.width = `${seasonProgress}%`;
}
        const tournamentInSeason = (state.tournamentCount % 4) + 1;
        const seasonTimelineHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                ${[1, 2, 3, 4].map(num => `
                    <div style="text-align: center; flex: 1;">
                        <div style="width: 40px; height: 40px; margin: 0 auto 10px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
                            background: ${num === tournamentInSeason ? 'var(--accent)' : num < tournamentInSeason ? 'var(--success)' : 'var(--secondary)'};
                            color: white; font-weight: 600;">
                            ${num}
                        </div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">
                            ${num === 4 ? 'Elimination' : 'Swiss'}
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
        
        document.getElementById('seasonTimeline').innerHTML = seasonTimelineHTML;
        
        const seasonProgress = (tournamentInSeason / 4) * 100;
        document.getElementById('seasonProgressText').textContent = `${tournamentInSeason}/4`;
        document.getElementById('seasonProgressFill').style.width = `${seasonProgress}%`;
    

    function updateStatistics() {
        const totalPlayers = state.players.length;
        const totalMatches = state.tournamentHistory.reduce((sum, t) => sum + (t.matches?.length || 0), 0) + 
                            (state.activeTournament?.matches?.length || 0);
        
        const totalWins = state.players.reduce((sum, p) => sum + (p.wins || 0), 0);
        const totalLosses = state.players.reduce((sum, p) => sum + (p.losses || 0), 0);
        const totalElo = Object.values(state.eloRatings).reduce((sum, elo) => sum + elo, state.systemSettings.initialElo * totalPlayers);
        
        const avgElo = totalPlayers > 0 ? Math.round(totalElo / totalPlayers) : state.systemSettings.initialElo;
        const winRate = totalWins + totalLosses > 0 ? Math.round((totalWins / (totalWins + totalLosses)) * 100) : 0;
        
        document.getElementById('totalPlayers').textContent = totalPlayers;
        document.getElementById('totalMatches').textContent = totalMatches;
        document.getElementById('avgElo').textContent = avgElo;
        document.getElementById('winRate').textContent = `${winRate}%`;
    }

    function updateRecentMatches() {
        const recentMatches = [];
        
        if (state.activeTournament?.matches) {
            state.activeTournament.matches
                .filter(m => m.winner)
                .forEach(m => {
                    recentMatches.push({
                        ...m,
                        tournament: state.activeTournament.name,
                        date: m.endedAt || state.activeTournament.startTime
                    });
                });
        }
        
        state.tournamentHistory.forEach(tournament => {
            tournament.matches
                ?.filter(m => m.winner)
                .slice(0, 2)
                .forEach(m => {
                    recentMatches.push({
                        ...m,
                        tournament: tournament.name,
                        date: m.endedAt || tournament.startTime
                    });
                });
        });
        
        recentMatches.sort((a, b) => new Date(b.date) - new Date(a.date));
        const topRecentMatches = recentMatches.slice(0, 8);
        
        const recentMatchesHTML = topRecentMatches.map(match => {
            const date = new Date(match.date);
            const timeAgo = getTimeAgo(date);
            
            return `
                <div style="padding: 12px; border-bottom: 1px solid var(--border);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <div>
                            <span style="font-weight: 600; color: var(--success);">${match.player1.name.substring(0, 12)}</span>
                            <span style="margin: 0 8px; color: var(--text-secondary);">vs</span>
                            <span style="font-weight: 600;">${match.player2.name.substring(0, 12)}</span>
                        </div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">
                            ${timeAgo}
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">
                            ${match.tournament.substring(0, 20)}...
                        </div>
                        <div style="font-size: 0.9rem; font-weight: 500; color: var(--accent);">
                            üèÜ ${match.winner === match.player1.id ? match.player1.name.substring(0, 10) : match.player2.name.substring(0, 10)}
                        </div>
                    </div>
                </div>
            `;
        }).join('');
        
        document.getElementById('recentMatchesList').innerHTML = recentMatchesHTML || 
            '<div class="empty-state">No recent matches</div>';
    }

    function getTimeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + "y ago";
        
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + "mo ago";
        
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + "d ago";
        
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + "h ago";
        
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + "m ago";
        
        return Math.floor(seconds) + "s ago";
    }

    function renderChart() {
        const ctx = document.getElementById('seasonChart').getContext('2d');
        
        if (chart) {
            chart.destroy();
        }
        
        const topPlayers = [...state.players]
            .sort((a, b) => {
                if (a.elo !== undefined && b.elo !== undefined) {
                    return b.elo - a.elo;
                }
                return (b.points || 0) - (a.points || 0);
            })
            .slice(0, 5);
        
        const tournamentCount = Math.min(state.tournamentCount, 4);
        const labels = ['Start'];
        for (let i = 1; i <= tournamentCount; i++) {
            labels.push(`T${i}`);
        }
        
        const colors = [
            'rgb(228, 63, 90)',
            'rgb(31, 64, 104)',
            'rgb(46, 204, 113)',
            'rgb(243, 156, 18)',
            'rgb(155, 89, 182)'
        ];
        
        const theme = document.body.getAttribute('data-theme') || 'light';
        const gridColor = theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
        const textColor = theme === 'dark' ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)';
        
        chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: topPlayers.map((player, index) => ({
                    label: player.name,
                    data: player.history?.slice(0, 1 + tournamentCount) || Array(1 + tournamentCount).fill(0),
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    borderWidth: 3,
                    tension: 0.3,
                    pointRadius: 6,
                    pointHoverRadius: 8,
                    pointBackgroundColor: colors[index % colors.length],
                    fill: true
                }))
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            color: textColor,
                            font: {
                                family: 'Inter',
                                size: 12
                            },
                            padding: 20,
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: theme === 'dark' ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.9)',
                        titleColor: textColor,
                        bodyColor: textColor,
                        borderColor: 'var(--accent)',
                        borderWidth: 1,
                        cornerRadius: 8,
                        padding: 12
                    }
                },
                scales: {
                    x: {
                        grid: {
                            color: gridColor
                        },
                        ticks: {
                            color: textColor
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: gridColor
                        },
                        ticks: {
                            color: textColor
                        },
                        title: {
                            display: true,
                            text: 'Points',
                            color: textColor
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'nearest'
                },
                animation: {
                    duration: 1000,
                    easing: 'easeOutQuart'
                }
            }
        });
    }

    function updateSeasonInfo() {
        document.getElementById('currentSeason').textContent = state.season;
        document.getElementById('currentSeasonNum').textContent = state.season;
        document.getElementById('currentChampion').textContent = state.champion;
        
        updateAutoQualifiers();
    }

    // Filter Players Function
    function filterPlayers(filterType) {
        const searchTerm = document.getElementById('searchPlayers').value.toLowerCase();
        const items = document.querySelectorAll('.player-item');
        
        document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
        
        items.forEach(item => {
            const playerName = item.querySelector('.player-name').textContent.toLowerCase();
            const playerRank = item.querySelector('.player-tag').textContent.toLowerCase();
            
            let matchesSearch = playerName.includes(searchTerm);
            let matchesFilter = true;
            
            const rankValue = parseRank(playerRank);
            
            switch(filterType) {
                case 'kyu':
                    matchesFilter = playerRank.includes('k');
                    break;
                case 'dan':
                    matchesFilter = playerRank.includes('d');
                    break;
                case 'low':
                    matchesFilter = rankValue >= 10 && rankValue <= 30;
                    break;
                case 'mid':
                    matchesFilter = (rankValue >= 1 && rankValue <= 5) || playerRank === '1k';
                    break;
                case 'high':
                    matchesFilter = rankValue >= 5 && rankValue <= 9 && playerRank.includes('d');
                    break;
                case 'all':
                default:
                    matchesFilter = true;
            }
            
            item.style.display = matchesSearch && matchesFilter ? 'flex' : 'none';
        });
    }

    function parseRank(rank) {
        const match = rank.match(/(\d+)([kd])/);
        if (match) {
            return parseInt(match[1]);
        }
        return 0;
    }

// Ajoutez cette fonction apr√®s les autres fonctions (~ligne 6200)
function sortPlayersByPointsThenElo(players) {
    return [...players].sort((a, b) => {
        // D'abord par points
        if (b.points !== a.points) {
            return b.points - a.points;
        }
        // Ensuite par Elo
        const eloA = state.eloRatings[a.id] || state.systemSettings.initialElo;
        const eloB = state.eloRatings[b.id] || state.systemSettings.initialElo;
        return eloB - eloA;
        // Ensuite par nom (pour √©viter les √©galit√©s)
        if (a.name !== b.name) {
            return a.name.localeCompare(b.name);
        }
        return 0;
    });
}

    // Helper Functions
    function selectAllPlayers() {
        document.querySelectorAll('.enroll-check').forEach(checkbox => {
            checkbox.checked = true;
        });
    }

    function deselectAllPlayers() {
        document.querySelectorAll('.enroll-check').forEach(checkbox => {
            checkbox.checked = false;
        });
    }
// Ajoutez cette fonction AVANT le DOMContentLoaded
function forceAdminButtonsDisplay() {
    console.log("üîß V√©rification de l'affichage admin...");
    
    if (isAdmin) {
        console.log("üëë Mode admin d√©tect√©, for√ßage de l'affichage...");
        
        // 1. Supprimer guest-mode
        document.querySelector('.container')?.classList.remove('guest-mode');
        
        // 2. Afficher tous les √©l√©ments cach√©s
        document.querySelectorAll('.admin-hidden').forEach(el => {
            el.classList.remove('admin-hidden');
        });
        
        // 3. Forcer l'affichage CSS
        document.querySelectorAll('.win-btn, .swap-colors-btn').forEach(btn => {
            btn.style.display = 'block';
            btn.style.visibility = 'visible';
            btn.style.opacity = '1';
        });
        
        // 4. V√©rifier les boutons de lien
        document.querySelectorAll('.match-card').forEach(card => {
            const centerDiv = card.querySelector('.match-status');
            if (centerDiv && !centerDiv.querySelector('button, a')) {
                const btn = document.createElement('button');
                btn.textContent = '+ Add Game Link';
                btn.onclick = function() {
                    const matchId = card.dataset.matchId;
                    if (matchId) {
                        promptGameLink(matchId);
                    }
                };
                btn.style.cssText = 'padding: 10px 20px; background: var(--secondary); color: white; border: none; border-radius: 8px; cursor: pointer; margin: 10px;';
                centerDiv.appendChild(btn);
            }
        });
    }
}

// Et modifiez la fin du DOMContentLoaded :
document.addEventListener('DOMContentLoaded', () => {
    const savedTheme = localStorage.getItem('meijin-theme') || 'dark';
    document.body.setAttribute('data-theme', savedTheme);
    document.getElementById('themeIcon').textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
    
    document.getElementById('searchPlayers').addEventListener('input', () => filterPlayers('all'));
    
    // Mode admin d√©sactiv√© par d√©faut
    isAdmin = false;
    document.getElementById('adminControls').style.display = 'none';
    document.getElementById('authSection').style.display = 'flex';
    
    // Masquer les √©l√©ments admin au chargement
    toggleAdminElements(false);
    
    // Mettre √† jour l'indicateur de mode
    updateModeIndicator();
    
    // Exposer les fonctions au niveau global
    // ... [toutes vos fonctions window.* = ...]
    
    // AJOUTEZ CETTE LIGNE :
    window.forceAdminButtonsDisplay = forceAdminButtonsDisplay;
    
    console.log("‚úÖ Application initialis√©e sans erreurs");
    
    // EX√âCUTEZ automatiquement apr√®s un d√©lai
    setTimeout(() => {
        if (isAdmin) {
            forceAdminButtonsDisplay();
            updateMatchesDisplay();
        }
    }, 1500);
});

// ============================================================
// FONCTIONS POUR AFFICHER LES ROUNDS
// ============================================================

function toggleTournamentRounds(tournamentId) {
    const roundsDiv = document.getElementById(`rounds_${tournamentId}`);
    const button = event.target;
    
    if (roundsDiv.style.display === 'none' || !roundsDiv.style.display) {
        roundsDiv.style.display = 'block';
        button.innerHTML = `üìä Hide Rounds`;
    } else {
        roundsDiv.style.display = 'none';
        button.innerHTML = `üìä View Rounds`;
    }
}

// Exposer les fonctions globalement
window.toggleTournamentRounds = toggleTournamentRounds;
    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        const savedTheme = localStorage.getItem('meijin-theme') || 'dark';
        document.body.setAttribute('data-theme', savedTheme);
        document.getElementById('themeIcon').textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        
        document.getElementById('searchPlayers').addEventListener('input', () => filterPlayers('all'));
        
        // Mode admin d√©sactiv√© par d√©faut
        isAdmin = false;
        document.getElementById('adminControls').style.display = 'none';
        document.getElementById('authSection').style.display = 'flex';
        
        // Masquer les √©l√©ments admin au chargement
        toggleAdminElements(false);
        
        // Mettre √† jour l'indicateur de mode
        updateModeIndicator();

        // Dans la section DOMContentLoaded (vers la fin du fichier, apr√®s les autres √©couteurs)
document.getElementById('adminPin').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        loginAdmin();
    } else if (e.key === 'e' && (e.ctrlKey || e.metaKey)) {
        // Commande pour effacer les matches de la ronde actuelle
        clearCurrentMatches();
        e.preventDefault(); // Emp√™cher le comportement par d√©faut
    }
});
        
        // Exposer les fonctions au niveau global
window.debugRoundArchive = debugRoundArchive;
window.debugMatches = debugMatches;
window.recoverLostRounds = recoverLostRounds;
window.manuallyArchiveCurrentRound = manuallyArchiveCurrentRound;
        window.updateRoundsArchive = updateRoundsArchive;
        
window.toggleRoundDetails = toggleRoundDetails;
window.filterRounds = filterRounds;
window.exportRoundData = exportRoundData;
window.deleteRound = deleteRound;
        window.getAppState = () => state;
        window.debugTournamentData = debugTournamentData;
        window.archiveCurrentRound = archiveCurrentRound;  // <-- AJOUTEZ CETTE LIGNE
        window.debugRoundArchiving = debugRoundArchiving;
        window.toggleTheme = toggleTheme;
        window.toggleTournamentRounds = toggleTournamentRounds;
window.toggleHistoryDetails = toggleHistoryDetails;
        window.loginAdmin = loginAdmin;
        window.logoutAdmin = logoutAdmin;
        window.addNewPlayer = addNewPlayer;
        window.startNewTournament = startNewTournament;
        window.createManualMatch = createManualMatch;
        window.swapMatchColors = swapMatchColors;
        window.setMatchWinner = setMatchWinner;
        window.endTournament = endTournament;
        window.generateSwissPairs = generateSwissPairs;
        window.clearCurrentMatches = clearCurrentMatches;
        window.selectAllPlayers = selectAllPlayers;
        window.deselectAllPlayers = deselectAllPlayers;
        window.filterPlayers = filterPlayers;
        window.switchTab = switchTab;
        window.promptGameLink = promptGameLink;
        window.swapAllMatchColors = swapAllMatchColors;
        window.randomizeAllColors = randomizeAllColors;
        window.swapSelectedPlayers = swapSelectedPlayers;
        window.toggleManualColor = toggleManualColor;
        window.sortPlayersByPointsThenElo = sortPlayersByPointsThenElo;
window.havePlayersPlayed = havePlayersPlayed;
window.checkDuplicateMatches = checkDuplicateMatches;
        window.createMultipleMatches = createMultipleMatches;
        window.filterHistory = filterHistory;
        window.toggleHistoryDetails = toggleHistoryDetails;
        window.resetAllMatchColors = resetAllMatchColors;
        window.clearAllMatches = clearAllMatches;
        window.sortPlayersByPointsThenElo = sortPlayersByPointsThenElo;

        window.randomizeAllMatches = randomizeAllMatches;
        window.exportTournamentData = exportTournamentData;
        window.loadMatchForEditing = loadMatchForEditing;
        window.swapMatchPlayers = swapMatchPlayers;
        window.saveMatchChanges = saveMatchChanges;
        window.deleteSelectedMatch = deleteSelectedMatch;
        window.setBulkWinner = setBulkWinner;
window.clearCurrentRoundMatches = clearCurrentRoundMatches;
        
        console.log("‚úÖ Application initialis√©e sans erreurs");
    });

</script>
</body>
</html>





