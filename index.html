<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meijin Go System - Professional Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Serif+JP:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-dark: #1a1a2e;
            --primary: #162447;
            --secondary: #1f4068;
            --accent: #e43f5a;
            --accent-light: #ff6b8b;
            --success: #2ecc71;
            --success-light: #4cd97b;
            --warning: #f39c12;
            --danger: #e74c3c;
            --gold: #ffd700;
            --silver: #c0c0c0;
            --bronze: #cd7f32;
            --stone-black: #000000;
            --stone-white: #ffffff;
            --goban-light: #dcb35c;
            --goban-dark: #5d4037;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --bg-light: #f8f9fa;
            --bg-card: #ffffff;
            --border: #e0e0e0;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            --shadow-hover: 0 8px 30px rgba(0, 0, 0, 0.12);
            --radius-lg: 16px;
            --radius-md: 12px;
            --radius-sm: 8px;
        }

        [data-theme="dark"] {
            --primary-dark: #0d1117;
            --primary: #161b22;
            --secondary: #21262d;
            --accent: #ff7b72;
            --accent-light: #ffa198;
            --success: #238636;
            --success-light: #2ea043;
            --warning: #d29922;
            --danger: #f85149;
            --gold: #ffd700;
            --silver: #c0c0c0;
            --bronze: #cd7f32;
            --stone-black: #000000;
            --stone-white: #ffffff;
            --goban-light: #5d4037;
            --goban-dark: #3e2723;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --bg-light: #0d1117;
            --bg-card: #161b22;
            --border: #30363d;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            --shadow-hover: 0 8px 30px rgba(0, 0, 0, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary) 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            margin-bottom: 30px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--stone-black) 0%, #333 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            font-weight: 700;
        }

        .logo-text {
            font-family: 'Noto Serif JP', serif;
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--gold) 0%, var(--accent-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .theme-toggle {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: var(--radius-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .auth-section {
            display: flex;
            gap: 10px;
        }

        .auth-input {
            padding: 10px 15px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--bg-card);
            color: var(--text-primary);
            min-width: 180px;
        }

        .btn {
            padding: 10px 24px;
            border-radius: var(--radius-md);
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(228, 63, 90, 0.3);
        }

        .btn-secondary {
            background: var(--secondary);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success) 0%, var(--success-light) 100%);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        /* Game Format Banner */
        .format-banner {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: 20px 30px;
            margin-bottom: 30px;
            border-left: 4px solid var(--gold);
            box-shadow: var(--shadow);
        }

        .format-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .format-details {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            color: var(--text-secondary);
        }

        .format-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        .format-item::before {
            content: "‚Ä¢";
            color: var(--accent);
            font-weight: bold;
        }

        /* Champion Section */
        .champion-section {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1) 0%, rgba(228, 63, 90, 0.1) 100%);
            border-radius: var(--radius-lg);
            padding: 40px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        .champion-section::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 20% 50%, rgba(255, 215, 0, 0.1) 0%, transparent 50%);
        }

        .champion-title {
            font-family: 'Noto Serif JP', serif;
            font-size: 1.4rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        .champion-name {
            font-size: 3.5rem;
            font-weight: 900;
            text-align: center;
            background: linear-gradient(135deg, var(--gold) 0%, var(--accent-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .qualifiers-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .qualifiers-label {
            font-size: 1.1rem;
            color: var(--text-secondary);
            text-align: center;
        }

        .qualifiers-badges {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .qualifier-badge {
            background: linear-gradient(135deg, var(--secondary) 0%, var(--primary) 100%);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .qualifier-badge::before {
            content: "üéØ";
            font-size: 1.2rem;
        }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: 30px;
            margin-bottom: 25px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-hover);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border);
        }

        .card-title {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Player Management */
        .add-player-form {
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-md);
            padding: 20px;
            margin-bottom: 25px;
            border: 2px dashed var(--border);
            display: none;
        }

        .add-player-form.visible {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .form-grid {
            display: grid;
            grid-template-columns: 2fr 1fr auto;
            gap: 10px;
            align-items: end;
        }

        .form-input {
            padding: 12px 16px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(228, 63, 90, 0.1);
        }

        /* Rankings List */
        .rankings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .search-box {
            position: relative;
            flex: 1;
            max-width: 300px;
        }

        .search-input {
            width: 100%;
            padding: 12px 16px 12px 40px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-primary);
        }

        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }

        .filter-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .filter-btn {
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .filter-btn:hover,
        .filter-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .player-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .player-item {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            background: var(--bg-light);
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .player-item:hover {
            background: rgba(228, 63, 90, 0.05);
            border-color: var(--accent-light);
            transform: translateX(5px);
        }

        .player-item.top-3 {
            border-left: 4px solid;
        }

        .player-item:nth-child(1) {
            border-left-color: var(--gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
        }

        .player-item:nth-child(2) {
            border-left-color: var(--silver);
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.05) 0%, transparent 100%);
        }

        .player-item:nth-child(3) {
            border-left-color: var(--bronze);
            background: linear-gradient(135deg, rgba(205, 127, 50, 0.05) 0%, transparent 100%);
        }

        .player-rank {
            width: 40px;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-secondary);
            text-align: center;
        }

        .player-info {
            flex: 1;
            min-width: 0;
        }

        .player-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .player-meta {
            display: flex;
            gap: 12px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .player-tag {
            background: var(--secondary);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .player-stats {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .player-points {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--accent);
        }

        .player-record {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Statistics */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, var(--bg-light) 0%, transparent 100%);
            border-radius: var(--radius-md);
            padding: 20px;
            border: 1px solid var(--border);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Chart Container */
        .chart-container {
            position: relative;
            height: 320px;
            width: 100%;
            background: var(--bg-light);
            border-radius: var(--radius-md);
            padding: 20px;
            margin-top: 15px;
        }

        /* Tournament Section */
        .tournament-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .tournament-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent);
            margin: 0;
        }

        .tournament-meta {
            display: flex;
            gap: 15px;
            align-items: center;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .tournament-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* Manual Pairing */
        .pairing-section {
            background: linear-gradient(135deg, rgba(31, 64, 104, 0.1) 0%, transparent 100%);
            border-radius: var(--radius-md);
            padding: 25px;
            margin: 25px 0;
            border: 1px solid var(--border);
        }

        .pairing-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pairing-form {
            display: grid;
            grid-template-columns: 1fr auto 1fr auto;
            gap: 15px;
            align-items: center;
        }

        .vs-separator {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent);
            text-align: center;
        }

        /* Matches Zone */
        .matches-grid {
            display: grid;
            gap: 15px;
            margin-top: 20px;
        }

        .match-card {
            background: var(--bg-light);
            border-radius: var(--radius-md);
            padding: 20px;
            border: 2px solid var(--border);
            transition: all 0.3s ease;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 30px;
            align-items: center;
        }

        .match-card.completed {
            border-color: var(--success);
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.05) 0%, transparent 100%);
        }

        .match-player {
            text-align: center;
            padding: 15px;
            border-radius: var(--radius-md);
            transition: all 0.3s ease;
        }

        .match-player.winner {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.1) 0%, transparent 100%);
            border: 2px solid var(--success);
        }

        .stone-display {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 0 auto 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            position: relative;
        }

        .stone-display.black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
        }

        .stone-display.white {
            background: radial-gradient(circle at 30% 30%, #fff, #f0f0f0);
            border: 2px solid #ddd;
        }

        .player-label {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .player-subtext {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 15px;
        }

        .win-btn {
            padding: 10px 20px;
            border-radius: var(--radius-md);
            border: none;
            background: linear-gradient(135deg, var(--success) 0%, var(--success-light) 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .win-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(46, 204, 113, 0.3);
        }

        .match-status {
            text-align: center;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--accent);
        }

        /* Tournament Setup */
        .enrollment-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
            margin: 25px 0;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }

        .enrollment-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-light);
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .enrollment-item:hover {
            background: rgba(228, 63, 90, 0.05);
            border-color: var(--accent-light);
        }

        .enrollment-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .enrollment-actions {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }

        /* Progress Bar */
        .progress-container {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid var(--border);
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .progress-bar {
            height: 10px;
            background: var(--bg-light);
            border-radius: 5px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-light) 100%);
            transition: width 0.5s ease;
        }

        /* Notifications */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .notification {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 16px 20px;
            border-left: 4px solid;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-width: 300px;
            max-width: 400px;
            animation: slideInRight 0.3s ease;
        }

        .notification.success {
            border-left-color: var(--success);
        }

        .notification.error {
            border-left-color: var(--danger);
        }

        .notification.info {
            border-left-color: var(--secondary);
        }

        .notification.warning {
            border-left-color: var(--warning);
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 20px;
                text-align: center;
            }

            .main-grid {
                grid-template-columns: 1fr;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }

            .pairing-form {
                grid-template-columns: 1fr;
            }

            .match-card {
                grid-template-columns: 1fr;
                text-align: center;
            }

            .match-status {
                padding: 15px 0;
            }

            .tournament-header {
                flex-direction: column;
                align-items: stretch;
            }

            .tournament-controls {
                justify-content: center;
            }

            .champion-name {
                font-size: 2.5rem;
            }
        }

        /* Animations */
        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }

        /* Loading States */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Badges */
        .badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .badge-gold {
            background: var(--gold);
            color: var(--primary-dark);
        }

        .badge-silver {
            background: var(--silver);
            color: var(--primary-dark);
        }

        .badge-bronze {
            background: var(--bronze);
            color: white;
        }

        .badge-success {
            background: var(--success);
            color: white;
        }

        /* Tournament Type Indicator */
        .tournament-type {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            background: var(--secondary);
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
        }

        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-light);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
    </style>
</head>
<body>
<div class="container">
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <div class="logo-icon">Á¢Å</div>
            <h1 class="logo-text">Meijin System</h1>
        </div>
        <div class="header-controls">
            <button onclick="toggleTheme()" class="theme-toggle">
                <span id="themeIcon">üåô</span> Theme
            </button>
            <div class="auth-section" id="authSection">
                <input type="password" id="adminPin" class="auth-input" placeholder="Admin PIN">
                <button onclick="loginAdmin()" class="btn btn-primary">Login</button>
            </div>
            <div id="adminControls" style="display: none;">
                <span style="margin-right: 15px; font-weight: 600; color: var(--accent);">Admin Mode</span>
                <button onclick="logoutAdmin()" class="btn btn-danger">Logout</button>
            </div>
        </div>
    </div>

    <!-- Game Format Banner -->
    <div class="format-banner">
        <div class="format-title">
            <span>üéÆ Game Format</span>
        </div>
        <div class="format-details">
            <div class="format-item">Fischer 45min + 15s increment</div>
            <div class="format-item">6.5 points komi</div>
            <div class="format-item">Tournaments 1-3: Swiss System</div>
            <div class="format-item">Tournament 4: Single Elimination</div>
            <div class="format-item">Top 2 after 3 tournaments auto-qualify</div>
        </div>
    </div>

    <!-- Champion Section -->
    <div id="championSection" class="champion-section">
        <div class="champion-title">CURRENT MEIJIN CHAMPION</div>
        <h1 id="currentChampion" class="champion-name">---</h1>
        <div class="qualifiers-info">
            <div class="qualifiers-label">Next auto-qualifiers (after 3 tournaments):</div>
            <div class="qualifiers-badges">
                <span class="qualifier-badge" id="qualifier1">---</span>
                <span class="qualifier-badge" id="qualifier2">---</span>
            </div>
            <div id="seasonEndMessage" style="margin-top: 20px; text-align: center; color: var(--text-secondary); font-size: 0.9rem;">
                Top 2 players after 3 tournaments auto-qualify for the final
            </div>
        </div>
    </div>

    <!-- Main Grid -->
    <div class="main-grid">
        <!-- Left Column -->
        <aside>
            <!-- Rankings Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üèÜ Global Rankings</h2>
                </div>

                <!-- Add Player Form (Admin Only) -->
                <div id="addPlayerForm" class="add-player-form">
                    <div class="form-grid">
                        <div>
                            <input type="text" id="newPlayerName" class="form-input" placeholder="Player name">
                        </div>
                        <div>
                            <select id="newPlayerRank" class="form-input">
                                <option value="30k">30k</option>
                                <option value="20k">20k</option>
                                <option value="10k">10k</option>
                                <option value="5k">5k</option>
                                <option value="1k" selected>1k</option>
                                <option value="1d">1d</option>
                                <option value="5d">5d</option>
                                <option value="9d">9d</option>
                            </select>
                        </div>
                        <div>
                            <button onclick="addNewPlayer()" class="btn btn-primary">Add</button>
                        </div>
                    </div>
                </div>

                <!-- Search and Filter -->
                <div class="rankings-header">
                    <div class="search-box">
                        <span class="search-icon">üîç</span>
                        <input type="text" id="searchPlayers" class="search-input" placeholder="Search players...">
                    </div>
                </div>

                <div class="filter-buttons">
                    <button onclick="filterPlayers('all')" class="filter-btn active">All</button>
                    <button onclick="filterPlayers('kyu')" class="filter-btn">Kyu (30k-1k)</button>
                    <button onclick="filterPlayers('dan')" class="filter-btn">Dan (1d-9d)</button>
                    <button onclick="filterPlayers('low')" class="filter-btn">30k-10k</button>
                    <button onclick="filterPlayers('mid')" class="filter-btn">5k-1d</button>
                    <button onclick="filterPlayers('high')" class="filter-btn">5d-9d</button>
                </div>

                <!-- Rankings List -->
                <div class="player-list" id="rankingsList">
                    <!-- Players will be listed here -->
                </div>
            </div>

            <!-- Statistics Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìä Statistics</h2>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalPlayers">0</div>
                        <div class="stat-label">Total Players</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalMatches">0</div>
                        <div class="stat-label">Total Matches</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgPoints">0</div>
                        <div class="stat-label">Avg Points</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="winRate">0%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                </div>
            </div>

            <!-- Chart Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìà Points Evolution</h2>
                </div>
                <div class="chart-container">
                    <canvas id="seasonChart"></canvas>
                </div>
            </div>
        </aside>

        <!-- Right Column -->
        <main>
            <!-- Active Tournament -->
            <div id="activeTournamentCard" class="card" style="display: none;">
                <div class="tournament-header">
                    <div>
                        <h2 id="tournamentTitle" class="tournament-title">Active Tournament</h2>
                        <div class="tournament-meta">
                            <span>Round: <span id="currentRound">1</span></span>
                            <span>Players: <span id="tournamentPlayerCount">0</span></span>
                            <span id="tournamentTypeBadge" class="tournament-type">
                                <span id="tournamentTypeIcon">‚ôüÔ∏è</span>
                                <span id="tournamentTypeText">Swiss System</span>
                            </span>
                        </div>
                    </div>
                    <div class="tournament-controls">
                        <button onclick="generateSwissPairs()" class="btn btn-secondary">
                            <span>üîÄ</span> Generate Pairs
                        </button>
                        <button onclick="clearCurrentMatches()" class="btn btn-warning">
                            <span>üîÑ</span> New Round
                        </button>
                        <button onclick="endTournament()" class="btn btn-danger">
                            <span>üèÅ</span> End Tournament
                        </button>
                    </div>
                </div>

                <!-- Manual Pairing -->
                <div id="manualPairingSection" class="pairing-section">
                    <div class="pairing-title">üîß Manual Pairing</div>
                    <div class="pairing-form">
                        <select id="player1Select" class="form-input">
                            <option value="">Select player 1</option>
                        </select>
                        <div class="vs-separator">VS</div>
                        <select id="player2Select" class="form-input">
                            <option value="">Select player 2</option>
                        </select>
                        <button onclick="createManualMatch()" class="btn btn-success">
                            <span>‚ûï</span> Create Match
                        </button>
                    </div>
                </div>

                <!-- Matches Zone -->
                <div class="matches-grid" id="matchesZone">
                    <!-- Matches will be displayed here -->
                </div>

                <!-- Tournament Progress -->
                <div class="progress-container">
                    <div class="progress-header">
                        <span>Tournament Progress</span>
                        <span id="matchProgress">0/0 matches</span>
                    </div>
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                    </div>
                </div>
            </div>

            <!-- Tournament Setup -->
            <div id="tournamentSetupCard" class="card">
                <div class="card-header">
                    <h2 class="card-title">üéØ New Tournament</h2>
                    <div style="color: var(--text-secondary); font-size: 0.9rem;">
                        Season: <span id="currentSeason">1</span> ‚Ä¢ Tournament: <span id="nextTournamentNumber">1</span>/4
                    </div>
                </div>

                <div style="margin: 20px 0;">
                    <input type="text" id="tournamentName" class="form-input" placeholder="Tournament name" 
                           style="width: 100%; font-size: 1.1rem; padding: 15px;">
                </div>

                <h3 style="margin-bottom: 15px; color: var(--text-primary);">Select Participants</h3>
                <div id="enrollmentZone" class="enrollment-grid">
                    <!-- Players will be listed here -->
                </div>

                <div class="enrollment-actions">
                    <button onclick="selectAllPlayers()" class="btn btn-secondary" style="flex: 1;">
                        <span>‚úÖ</span> Select All
                    </button>
                    <button onclick="deselectAllPlayers()" class="btn btn-secondary" style="flex: 1;">
                        <span>‚ùå</span> Deselect All
                    </button>
                    <button onclick="startNewTournament()" id="startTournamentBtn" class="btn btn-primary" style="flex: 2;">
                        <span>üöÄ</span> Start Tournament
                    </button>
                </div>
            </div>

            <!-- Recent Matches -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìú Recent Matches</h2>
                </div>
                <div id="recentMatchesList">
                    <!-- Recent matches will be displayed here -->
                </div>
            </div>
        </main>
    </div>
</div>

<!-- Notification Container -->
<div id="notificationContainer" class="notification-container"></div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, doc, onSnapshot, updateDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyDzse9aVDIAFscTbGs-3Disy2wdRHWPRF0",
        authDomain: "meijin-system.firebaseapp.com",
        projectId: "meijin-system",
        storageBucket: "meijin-system.firebasestorage.app",
        messagingSenderId: "935283801474",
        appId: "1:935283801474:web:4e161bff3b1c6ffb77a39b"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    let state = {
        players: [],
        activeTournament: null,
        completedTournaments: [],
        season: 1,
        tournamentCount: 0,
        champion: "None",
        autoQualifiers: [],
        lastAction: "System initialized",
        stats: {
            totalMatches: 0,
            totalWins: 0,
            totalLosses: 0
        },
        eloRatings: {} // Store Elo ratings for each player
    };

    let isAdmin = false;
    let chart = null;
    const initialElo = 1500; // Starting Elo rating

    // Theme Management
    function toggleTheme() {
        const currentTheme = document.body.getAttribute('data-theme') || 'light';
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        document.body.setAttribute('data-theme', newTheme);
        localStorage.setItem('meijin-theme', newTheme);
        
        const themeIcon = document.getElementById('themeIcon');
        themeIcon.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        
        if (chart) {
            chart.destroy();
            renderChart();
        }
        
        showNotification(`${newTheme.charAt(0).toUpperCase() + newTheme.slice(1)} theme activated`, 'info');
    }

    // Admin Authentication
    function loginAdmin() {
        const pin = document.getElementById('adminPin').value;
        if (pin === "159753") {
            isAdmin = true;
            document.getElementById('authSection').style.display = 'none';
            document.getElementById('adminControls').style.display = 'flex';
            document.getElementById('addPlayerForm').classList.add('visible');
            showNotification('Admin login successful', 'success');
        } else {
            showNotification('Incorrect PIN', 'error');
        }
    }

    function logoutAdmin() {
        isAdmin = false;
        document.getElementById('authSection').style.display = 'flex';
        document.getElementById('adminControls').style.display = 'none';
        document.getElementById('addPlayerForm').classList.remove('visible');
        showNotification('Logged out successfully', 'info');
    }

    // Notification System
    function showNotification(message, type = 'info') {
        const container = document.getElementById('notificationContainer');
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = `
            <div style="flex: 1;">${message}</div>
            <button onclick="this.parentElement.remove()" style="background: none; border: none; color: inherit; cursor: pointer; margin-left: 10px; font-size: 1.2rem;">√ó</button>
        `;
        
        container.appendChild(notification);
        
        // Remove notification after 5 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => notification.remove(), 300);
            }
        }, 5000);
    }

    // Firebase Initialization
    const systemRef = doc(db, "system", "current");

    onSnapshot(systemRef, (docSnap) => {
        if (docSnap.exists()) {
            const data = docSnap.data();
            state = {
                ...state,
                ...data,
                players: data.players || [],
                activeTournament: data.activeTournament || null,
                completedTournaments: data.completedTournaments || [],
                tournamentCount: data.tournamentCount || 0,
                season: data.season || 1,
                champion: data.champion || "None",
                autoQualifiers: data.autoQualifiers || [],
                eloRatings: data.eloRatings || {}
            };
            
            updateUI();
            updateAutoQualifiers();
        } else {
            // Initialize if document doesn't exist
            setDoc(systemRef, state).catch(console.error);
        }
    });

    // Elo Rating System
    function calculateElo(winnerElo, loserElo, kFactor = 32) {
        const expectedScoreWinner = 1 / (1 + Math.pow(10, (loserElo - winnerElo) / 400));
        const expectedScoreLoser = 1 - expectedScoreWinner;
        
        const newWinnerElo = Math.round(winnerElo + kFactor * (1 - expectedScoreWinner));
        const newLoserElo = Math.round(loserElo + kFactor * (0 - expectedScoreLoser));
        
        return { newWinnerElo, newLoserElo };
    }

    // Auto Qualifiers Logic - FIXED
    function updateAutoQualifiers() {
        const sortedPlayers = [...state.players].sort((a, b) => (b.points || 0) - (a.points || 0));
        
        // Update tournament number display
        const nextTournamentNum = state.tournamentCount + 1;
        document.getElementById('nextTournamentNumber').textContent = nextTournamentNum;
        
        // Show auto qualifiers only after 3 tournaments
        if (state.tournamentCount >= 3) {
            const qualifiers = sortedPlayers.slice(0, 2).map(p => p.name);
            
            document.getElementById('qualifier1').textContent = qualifiers[0] || '---';
            document.getElementById('qualifier2').textContent = qualifiers[1] || '---';
            
            // Update state with auto qualifiers
            if (JSON.stringify(state.autoQualifiers) !== JSON.stringify(qualifiers)) {
                state.autoQualifiers = qualifiers;
                updateDoc(systemRef, { autoQualifiers: qualifiers });
            }
            
            document.getElementById('seasonEndMessage').innerHTML = 
                `<strong>üéØ AUTO-QUALIFIED:</strong> ${qualifiers[0]} & ${qualifiers[1]}`;
        } else {
            document.getElementById('qualifier1').textContent = '---';
            document.getElementById('qualifier2').textContent = '---';
            const tournamentsLeft = 3 - state.tournamentCount;
            document.getElementById('seasonEndMessage').innerHTML = 
                `<strong>üìä Next auto-qualifiers in: ${tournamentsLeft} tournament${tournamentsLeft > 1 ? 's' : ''}</strong>`;
        }
    }

    // Player Management
    async function addNewPlayer() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const name = document.getElementById('newPlayerName').value.trim();
        const rank = document.getElementById('newPlayerRank').value;

        if (!name) {
            showNotification('Please enter a name', 'error');
            return;
        }

        if (state.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
            showNotification('Player already exists', 'error');
            return;
        }

        const newPlayer = {
            id: Date.now().toString(),
            name,
            rank,
            points: 0,
            wins: 0,
            losses: 0,
            draws: 0,
            elo: initialElo,
            history: [0],
            joinedDate: new Date().toISOString(),
            performance: {
                asBlack: { wins: 0, losses: 0 },
                asWhite: { wins: 0, losses: 0 }
            }
        };

        const updatedPlayers = [...state.players, newPlayer];
        const updatedEloRatings = {
            ...state.eloRatings,
            [newPlayer.id]: initialElo
        };
        
        await updateDoc(systemRef, { 
            players: updatedPlayers,
            eloRatings: updatedEloRatings
        });
        
        document.getElementById('newPlayerName').value = '';
        showNotification(`Player "${name}" added successfully`, 'success');
    }

    // Tournament Management
    async function startNewTournament() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const name = document.getElementById('tournamentName').value.trim() || `Tournament #${state.tournamentCount + 1}`;
        const enrolled = Array.from(document.querySelectorAll('.enroll-check:checked')).map(cb => cb.value);

        if (enrolled.length < 2) {
            showNotification('Select at least 2 players', 'error');
            return;
        }

        const participants = state.players.filter(p => enrolled.includes(p.id));
        
        // Determine tournament type based on tournament count
        const tournamentType = state.tournamentCount >= 3 ? 'single-elimination' : 'swiss';
        
        const tournament = {
            id: Date.now().toString(),
            name,
            participants,
            matches: [],
            startTime: new Date().toISOString(),
            status: 'active',
            round: 1,
            type: tournamentType,
            seedings: participants.map(p => ({ id: p.id, seed: Math.random() })).sort((a, b) => b.seed - a.seed)
        };

        await updateDoc(systemRef, { 
            activeTournament: tournament,
            lastAction: `üéØ Tournament "${name}" started with ${participants.length} players`
        });

        showNotification(`Tournament "${name}" started!`, 'success');
    }

    async function createManualMatch() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const p1Id = document.getElementById('player1Select').value;
        const p2Id = document.getElementById('player2Select').value;

        if (!p1Id || !p2Id) {
            showNotification('Select two players', 'error');
            return;
        }

        if (p1Id === p2Id) {
            showNotification('Player cannot play against themselves', 'error');
            return;
        }

        const p1 = state.activeTournament.participants.find(p => p.id === p1Id);
        const p2 = state.activeTournament.participants.find(p => p.id === p2Id);

        // Check for duplicate match
        const existingMatch = state.activeTournament.matches.find(m => 
            (m.player1.id === p1Id && m.player2.id === p2Id) ||
            (m.player1.id === p2Id && m.player2.id === p1Id)
        );

        if (existingMatch) {
            showNotification('Match already exists', 'error');
            return;
        }

        const newMatch = {
            id: Date.now().toString(),
            player1: p1,
            player2: p2,
            winner: null,
            round: state.activeTournament.round,
            player1IsBlack: Math.random() > 0.5,
            createdAt: new Date().toISOString()
        };

        const updatedMatches = [...state.activeTournament.matches, newMatch];
        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches,
            lastAction: `‚öîÔ∏è New match: ${p1.name} vs ${p2.name}`
        });
        
        showNotification('Match created successfully', 'success');
    }

    async function setMatchWinner(matchId, winnerId) {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const match = state.activeTournament.matches.find(m => m.id === matchId);
        const loserId = winnerId === match.player1.id ? match.player2.id : match.player1.id;
        
        const winner = state.players.find(p => p.id === winnerId);
        const loser = state.players.find(p => p.id === loserId);

        // Calculate Elo changes
        const winnerElo = state.eloRatings[winnerId] || initialElo;
        const loserElo = state.eloRatings[loserId] || initialElo;
        const eloChanges = calculateElo(winnerElo, loserElo);
        
        // Update Elo ratings
        const updatedEloRatings = {
            ...state.eloRatings,
            [winnerId]: eloChanges.newWinnerElo,
            [loserId]: eloChanges.newLoserElo
        };

        // Update players with Elo
        const updatedPlayers = state.players.map(p => {
            if (p.id === winnerId) {
                return {
                    ...p,
                    points: (p.points || 0) + 10,
                    wins: (p.wins || 0) + 1,
                    elo: eloChanges.newWinnerElo,
                    history: [...(p.history || [0]), (p.points || 0) + 10],
                    performance: {
                        ...p.performance,
                        [match.player1IsBlack && p.id === match.player1.id ? 'asBlack' : 'asWhite']: {
                            wins: (p.performance?.[match.player1IsBlack && p.id === match.player1.id ? 'asBlack' : 'asWhite']?.wins || 0) + 1,
                            losses: p.performance?.[match.player1IsBlack && p.id === match.player1.id ? 'asBlack' : 'asWhite']?.losses || 0
                        }
                    }
                };
            }
            if (p.id === loserId) {
                return {
                    ...p,
                    points: Math.max(0, (p.points || 0) - 5),
                    losses: (p.losses || 0) + 1,
                    elo: eloChanges.newLoserElo,
                    history: [...(p.history || [0]), Math.max(0, (p.points || 0) - 5)],
                    performance: {
                        ...p.performance,
                        [(!match.player1IsBlack && p.id === match.player1.id) || (match.player1IsBlack && p.id === match.player2.id) ? 'asBlack' : 'asWhite']: {
                            wins: p.performance?.[(!match.player1IsBlack && p.id === match.player1.id) || (match.player1IsBlack && p.id === match.player2.id) ? 'asBlack' : 'asWhite']?.wins || 0,
                            losses: (p.performance?.[(!match.player1IsBlack && p.id === match.player1.id) || (match.player1IsBlack && p.id === match.player2.id) ? 'asBlack' : 'asWhite']?.losses || 0) + 1
                        }
                    }
                };
            }
            return p;
        });

        // Update match
        const updatedMatches = state.activeTournament.matches.map(m => 
            m.id === matchId ? { 
                ...m, 
                winner: winnerId,
                eloChanges: {
                    winner: { from: winnerElo, to: eloChanges.newWinnerElo },
                    loser: { from: loserElo, to: eloChanges.newLoserElo }
                },
                endedAt: new Date().toISOString()
            } : m
        );

        await updateDoc(systemRef, {
            players: updatedPlayers,
            eloRatings: updatedEloRatings,
            "activeTournament.matches": updatedMatches,
            lastAction: `üèÜ ${winner.name} defeated ${loser.name}! (+${eloChanges.newWinnerElo - winnerElo} Elo)`
        });

        showNotification(`${winner.name} wins! Elo: +${eloChanges.newWinnerElo - winnerElo}`, 'success');
    }

    async function endTournament() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        if (!confirm('End this tournament and update rankings?')) {
            return;
        }

        let updatedTournamentCount = state.tournamentCount + 1;
        let updatedSeason = state.season;
        let updatedChampion = state.champion;
        
        // Calculate tournament results
        const tournamentResults = state.activeTournament.participants.map(p => {
            const wins = state.activeTournament.matches.filter(m => m.winner === p.id).length;
            const losses = state.activeTournament.matches.filter(m => 
                (m.player1.id === p.id || m.player2.id === p.id) && 
                m.winner && 
                m.winner !== p.id
            ).length;
            return { 
                ...p, 
                tournamentWins: wins,
                tournamentLosses: losses,
                tournamentPoints: wins * 2 - losses // Simple point system
            };
        }).sort((a, b) => b.tournamentPoints - a.tournamentPoints);

        // Update champion if this is the 4th tournament
        if (updatedTournamentCount >= 4 && tournamentResults.length > 0 && tournamentResults[0].tournamentWins > 0) {
            const tournamentChampion = tournamentResults[0];
            updatedChampion = tournamentChampion.name;
            updatedTournamentCount = 0;
            updatedSeason += 1;
            
            // Reset for new season
            const resetPlayers = state.players.map(p => ({
                ...p,
                points: 0,
                wins: 0,
                losses: 0,
                draws: 0,
                history: [0]
            }));

            await updateDoc(systemRef, {
                activeTournament: null,
                completedTournaments: [...state.completedTournaments, state.activeTournament],
                tournamentCount: 0,
                season: updatedSeason,
                players: resetPlayers,
                champion: updatedChampion,
                autoQualifiers: [],
                lastAction: `üèÜ ${tournamentChampion.name} is the new Meijin Champion! Season ${updatedSeason} started.`
            });
        } else {
            await updateDoc(systemRef, {
                activeTournament: null,
                completedTournaments: [...state.completedTournaments, state.activeTournament],
                tournamentCount: updatedTournamentCount,
                champion: updatedChampion,
                lastAction: `üèÅ Tournament "${state.activeTournament.name}" ended`
            });
        }

        showNotification('Tournament ended successfully', 'success');
    }

    // UI Update Functions
    function updateUI() {
        updateRankings();
        updateTournamentView();
        updateStatistics();
        updateRecentMatches();
        renderChart();
        updateSeasonInfo();
    }

    function updateRankings() {
        const sortedPlayers = [...state.players].sort((a, b) => {
            // Sort by Elo if available, otherwise by points
            if (a.elo !== undefined && b.elo !== undefined) {
                return b.elo - a.elo;
            }
            return (b.points || 0) - (a.points || 0);
        });
        
        const rankingsHTML = sortedPlayers.map((player, index) => {
            const elo = state.eloRatings[player.id] || initialElo;
            const winRate = player.wins + player.losses > 0 
                ? Math.round((player.wins / (player.wins + player.losses)) * 100) 
                : 0;
            
            return `
                <div class="player-item ${index < 3 ? 'top-3' : ''}">
                    <div class="player-rank">${index + 1}</div>
                    <div class="player-info">
                        <div class="player-name">
                            ${player.name}
                            ${index === 0 ? '<span class="badge badge-gold">ü•á</span>' : ''}
                            ${index === 1 ? '<span class="badge badge-silver">ü•à</span>' : ''}
                            ${index === 2 ? '<span class="badge badge-bronze">ü•â</span>' : ''}
                        </div>
                        <div class="player-meta">
                            <span class="player-tag">${player.rank}</span>
                            <span>Elo: ${elo}</span>
                            <span>${player.wins || 0}W ${player.losses || 0}L</span>
                        </div>
                    </div>
                    <div class="player-stats">
                        <div class="player-points">${player.points || 0} pts</div>
                        <div class="player-record">${winRate}% win rate</div>
                    </div>
                </div>
            `;
        }).join('');

        document.getElementById('rankingsList').innerHTML = rankingsHTML || 
            '<div class="empty-state">No players registered yet</div>';
    }

    function updateTournamentView() {
        const tournamentTypeIcon = document.getElementById('tournamentTypeIcon');
        const tournamentTypeText = document.getElementById('tournamentTypeText');
        
        if (state.activeTournament) {
            document.getElementById('activeTournamentCard').style.display = 'block';
            document.getElementById('tournamentSetupCard').style.display = 'none';
            
            document.getElementById('tournamentTitle').textContent = state.activeTournament.name;
            document.getElementById('currentRound').textContent = state.activeTournament.round;
            document.getElementById('tournamentPlayerCount').textContent = state.activeTournament.participants.length;
            
            // Set tournament type display
            if (state.activeTournament.type === 'single-elimination') {
                tournamentTypeIcon.textContent = 'üèÜ';
                tournamentTypeText.textContent = 'Single Elimination';
            } else {
                tournamentTypeIcon.textContent = '‚ôüÔ∏è';
                tournamentTypeText.textContent = 'Swiss System';
            }
            
            // Update player selects
            const participants = state.activeTournament.participants || [];
            const playerOptions = participants.map(p => 
                `<option value="${p.id}">${p.name} (${p.rank})</option>`
            ).join('');
            
            document.getElementById('player1Select').innerHTML = `<option value="">Select player 1</option>${playerOptions}`;
            document.getElementById('player2Select').innerHTML = `<option value="">Select player 2</option>${playerOptions}`;
            
            // Update matches
            updateMatchesDisplay();
            
            // Update progress
            const totalMatches = participants.length * (participants.length - 1) / 2;
            const completedMatches = state.activeTournament.matches.filter(m => m.winner).length;
            const progress = totalMatches > 0 ? (completedMatches / totalMatches) * 100 : 0;
            
            document.getElementById('matchProgress').textContent = `${completedMatches}/${totalMatches} matches`;
            document.getElementById('progressFill').style.width = `${progress}%`;
        } else {
            document.getElementById('activeTournamentCard').style.display = 'none';
            document.getElementById('tournamentSetupCard').style.display = 'block';
            
            // Update enrollment zone
            updateEnrollmentZone();
        }
    }

    function updateMatchesDisplay() {
        if (!state.activeTournament) return;
        
        const matchesHTML = state.activeTournament.matches.map(match => {
            const isCompleted = !!match.winner;
            const winnerIsPlayer1 = match.winner === match.player1.id;
            
            return `
                <div class="match-card ${isCompleted ? 'completed' : ''}">
                    <div class="match-player ${winnerIsPlayer1 ? 'winner' : ''}">
                        <div class="stone-display ${match.player1IsBlack ? 'black' : 'white'}"></div>
                        <div class="player-label">${match.player1.name}</div>
                        <div class="player-subtext">${match.player1.rank}</div>
                        ${!isCompleted && isAdmin ? 
                            `<button onclick="setMatchWinner('${match.id}', '${match.player1.id}')" class="win-btn">Winner</button>` : 
                            (winnerIsPlayer1 ? '<div class="badge badge-success">WINNER</div>' : '')
                        }
                    </div>
                    
                    <div class="match-status">VS</div>
                    
                    <div class="match-player ${!winnerIsPlayer1 && isCompleted ? 'winner' : ''}">
                        <div class="stone-display ${!match.player1IsBlack ? 'black' : 'white'}"></div>
                        <div class="player-label">${match.player2.name}</div>
                        <div class="player-subtext">${match.player2.rank}</div>
                        ${!isCompleted && isAdmin ? 
                            `<button onclick="setMatchWinner('${match.id}', '${match.player2.id}')" class="win-btn">Winner</button>` : 
                            (!winnerIsPlayer1 && isCompleted ? '<div class="badge badge-success">WINNER</div>' : '')
                        }
                    </div>
                </div>
            `;
        }).join('');
        
        document.getElementById('matchesZone').innerHTML = matchesHTML || 
            '<div class="empty-state">No matches created yet</div>';
    }

    function updateEnrollmentZone() {
        const playersHTML = state.players.map(player => `
            <label class="enrollment-item">
                <input type="checkbox" class="enroll-check" value="${player.id}" checked>
                <span style="font-weight: 600;">${player.name}</span>
                <span style="margin-left: auto; font-size: 0.9rem; color: var(--text-secondary);">
                    ${player.rank} ‚Ä¢ ${state.eloRatings[player.id] || initialElo} Elo
                </span>
            </label>
        `).join('');
        
        document.getElementById('enrollmentZone').innerHTML = playersHTML || 
            '<div class="empty-state">No players available</div>';
    }

    function updateStatistics() {
        const totalPlayers = state.players.length;
        const totalMatches = state.completedTournaments.reduce((sum, t) => sum + (t.matches?.length || 0), 0) + 
                            (state.activeTournament?.matches?.length || 0);
        
        const totalWins = state.players.reduce((sum, p) => sum + (p.wins || 0), 0);
        const totalLosses = state.players.reduce((sum, p) => sum + (p.losses || 0), 0);
        const totalPoints = state.players.reduce((sum, p) => sum + (p.points || 0), 0);
        const totalElo = Object.values(state.eloRatings).reduce((sum, elo) => sum + elo, initialElo * totalPlayers);
        
        const avgPoints = totalPlayers > 0 ? Math.round(totalPoints / totalPlayers) : 0;
        const avgElo = totalPlayers > 0 ? Math.round(totalElo / totalPlayers) : initialElo;
        const winRate = totalWins + totalLosses > 0 ? Math.round((totalWins / (totalWins + totalLosses)) * 100) : 0;
        
        document.getElementById('totalPlayers').textContent = totalPlayers;
        document.getElementById('totalMatches').textContent = totalMatches;
        document.getElementById('avgPoints').textContent = avgPoints;
        document.getElementById('winRate').textContent = `${winRate}%`;
    }

    function updateRecentMatches() {
        const recentMatches = [];
        
        // Add matches from active tournament
        if (state.activeTournament?.matches) {
            state.activeTournament.matches
                .filter(m => m.winner)
                .forEach(m => {
                    recentMatches.push({
                        ...m,
                        tournament: state.activeTournament.name,
                        date: m.endedAt || state.activeTournament.startTime
                    });
                });
        }
        
        // Add matches from last completed tournament
        if (state.completedTournaments.length > 0) {
            const lastTournament = state.completedTournaments[state.completedTournaments.length - 1];
            lastTournament.matches
                ?.filter(m => m.winner)
                .slice(0, 5)
                .forEach(m => {
                    recentMatches.push({
                        ...m,
                        tournament: lastTournament.name,
                        date: m.endedAt || lastTournament.startTime
                    });
                });
        }
        
        // Sort by date and take top 10
        recentMatches.sort((a, b) => new Date(b.date) - new Date(a.date));
        const topRecentMatches = recentMatches.slice(0, 10);
        
        const recentMatchesHTML = topRecentMatches.map(match => {
            const date = new Date(match.date);
            const timeAgo = getTimeAgo(date);
            
            return `
                <div style="padding: 15px; border-bottom: 1px solid var(--border);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <div>
                            <span style="font-weight: 600; color: var(--success);">${match.player1.name}</span>
                            <span style="margin: 0 8px; color: var(--text-secondary);">vs</span>
                            <span style="font-weight: 600;">${match.player2.name}</span>
                        </div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary);">
                            ${timeAgo}
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">
                            ${match.tournament}
                        </div>
                        <div style="font-size: 0.9rem; font-weight: 500; color: var(--accent);">
                            üèÜ ${match.winner === match.player1.id ? match.player1.name : match.player2.name}
                        </div>
                    </div>
                </div>
            `;
        }).join('');
        
        document.getElementById('recentMatchesList').innerHTML = recentMatchesHTML || 
            '<div class="empty-state">No recent matches</div>';
    }

    function getTimeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + " years ago";
        
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + " months ago";
        
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + " days ago";
        
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + " hours ago";
        
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + " minutes ago";
        
        return Math.floor(seconds) + " seconds ago";
    }

    function renderChart() {
        const ctx = document.getElementById('seasonChart').getContext('2d');
        
        if (chart) {
            chart.destroy();
        }
        
        const topPlayers = [...state.players]
            .sort((a, b) => {
                if (a.elo !== undefined && b.elo !== undefined) {
                    return b.elo - a.elo;
                }
                return (b.points || 0) - (a.points || 0);
            })
            .slice(0, 5);
        
        const tournamentCount = Math.min(state.tournamentCount, 4);
        const labels = ['Start'];
        for (let i = 1; i <= tournamentCount; i++) {
            labels.push(`T${i}`);
        }
        
        const colors = [
            'rgb(228, 63, 90)',
            'rgb(31, 64, 104)',
            'rgb(46, 204, 113)',
            'rgb(243, 156, 18)',
            'rgb(155, 89, 182)'
        ];
        
        const theme = document.body.getAttribute('data-theme') || 'light';
        const gridColor = theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
        const textColor = theme === 'dark' ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)';
        
        chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: topPlayers.map((player, index) => ({
                    label: player.name,
                    data: player.history?.slice(0, 1 + tournamentCount) || Array(1 + tournamentCount).fill(0),
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    borderWidth: 3,
                    tension: 0.3,
                    pointRadius: 6,
                    pointHoverRadius: 8,
                    pointBackgroundColor: colors[index % colors.length],
                    fill: true
                }))
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            color: textColor,
                            font: {
                                family: 'Inter',
                                size: 12
                            },
                            padding: 20,
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: theme === 'dark' ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.9)',
                        titleColor: textColor,
                        bodyColor: textColor,
                        borderColor: 'var(--accent)',
                        borderWidth: 1,
                        cornerRadius: 8,
                        padding: 12
                    }
                },
                scales: {
                    x: {
                        grid: {
                            color: gridColor
                        },
                        ticks: {
                            color: textColor
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: gridColor
                        },
                        ticks: {
                            color: textColor
                        },
                        title: {
                            display: true,
                            text: 'Points',
                            color: textColor
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'nearest'
                },
                animation: {
                    duration: 1000,
                    easing: 'easeOutQuart'
                }
            }
        });
    }

    function updateSeasonInfo() {
        document.getElementById('currentSeason').textContent = state.season;
        document.getElementById('currentChampion').textContent = state.champion;
        
        const tournamentsLeft = 3 - state.tournamentCount;
        if (tournamentsLeft > 0) {
            document.getElementById('seasonEndMessage').innerHTML = 
                `<strong>üìä Next auto-qualifiers in: ${tournamentsLeft} tournament${tournamentsLeft > 1 ? 's' : ''}</strong>`;
        }
    }

    // Filter Players Function - FIXED
    function filterPlayers(filterType) {
        const searchTerm = document.getElementById('searchPlayers').value.toLowerCase();
        const items = document.querySelectorAll('.player-item');
        
        // Update active filter button
        document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
        
        items.forEach(item => {
            const playerName = item.querySelector('.player-name').textContent.toLowerCase();
            const playerRank = item.querySelector('.player-tag').textContent.toLowerCase();
            
            let matchesSearch = playerName.includes(searchTerm);
            let matchesFilter = true;
            
            // Parse rank to compare
            const rankValue = parseRank(playerRank);
            
            switch(filterType) {
                case 'kyu':
                    matchesFilter = playerRank.includes('k');
                    break;
                case 'dan':
                    matchesFilter = playerRank.includes('d');
                    break;
                case 'low':
                    matchesFilter = rankValue >= 10 && rankValue <= 30;
                    break;
                case 'mid':
                    matchesFilter = (rankValue >= 1 && rankValue <= 5) || playerRank === '1k';
                    break;
                case 'high':
                    matchesFilter = rankValue >= 5 && rankValue <= 9 && playerRank.includes('d');
                    break;
                case 'all':
                default:
                    matchesFilter = true;
            }
            
            item.style.display = matchesSearch && matchesFilter ? 'flex' : 'none';
        });
    }

    function parseRank(rank) {
        const match = rank.match(/(\d+)([kd])/);
        if (match) {
            return parseInt(match[1]);
        }
        return 0;
    }

    // Helper Functions
    function selectAllPlayers() {
        document.querySelectorAll('.enroll-check').forEach(checkbox => {
            checkbox.checked = true;
        });
    }

    function deselectAllPlayers() {
        document.querySelectorAll('.enroll-check').forEach(checkbox => {
            checkbox.checked = false;
        });
    }

    async function clearCurrentMatches() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        if (confirm('Clear all matches from current round?')) {
            await updateDoc(systemRef, {
                "activeTournament.matches": [],
                "activeTournament.round": (state.activeTournament.round || 1) + 1,
                lastAction: 'üîÑ New round started'
            });
            showNotification('New round started', 'info');
        }
    }

    async function generateSwissPairs() {
        if (!isAdmin || !state.activeTournament) {
            showNotification('Admin access required', 'error');
            return;
        }

        const participants = [...state.activeTournament.participants];
        const existingMatches = state.activeTournament.matches || [];
        
        // Calculate current scores
        const scores = participants.map(player => {
            const wins = existingMatches.filter(m => m.winner === player.id).length;
            const opponents = existingMatches
                .filter(m => m.player1.id === player.id || m.player2.id === player.id)
                .map(m => m.player1.id === player.id ? m.player2.id : m.player1.id);
            
            return {
                ...player,
                score: wins,
                opponents: new Set(opponents),
                played: opponents.length,
                elo: state.eloRatings[player.id] || initialElo
            };
        });

        // Sort by score, then by Elo (for Swiss system)
        scores.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            return b.elo - a.elo;
        });

        // Generate pairs
        const newMatches = [];
        const paired = new Set();

        for (let i = 0; i < scores.length; i++) {
            if (paired.has(scores[i].id)) continue;

            let foundOpponent = false;
            for (let j = i + 1; j < scores.length; j++) {
                if (!paired.has(scores[j].id) && !scores[i].opponents.has(scores[j].id)) {
                    newMatches.push({
                        id: Date.now() + j,
                        player1: scores[i],
                        player2: scores[j],
                        winner: null,
                        round: state.activeTournament.round || 1,
                        player1IsBlack: Math.random() > 0.5
                    });
                    
                    paired.add(scores[i].id);
                    paired.add(scores[j].id);
                    foundOpponent = true;
                    break;
                }
            }

            // If no suitable opponent found, try any unpaired player
            if (!foundOpponent) {
                for (let j = i + 1; j < scores.length; j++) {
                    if (!paired.has(scores[j].id)) {
                        newMatches.push({
                            id: Date.now() + j,
                            player1: scores[i],
                            player2: scores[j],
                            winner: null,
                            round: state.activeTournament.round || 1,
                            player1IsBlack: Math.random() > 0.5
                        });
                        
                        paired.add(scores[i].id);
                        paired.add(scores[j].id);
                        break;
                    }
                }
            }
        }

        const updatedMatches = [...existingMatches, ...newMatches];
        await updateDoc(systemRef, {
            "activeTournament.matches": updatedMatches,
            lastAction: `üé≤ Swiss pairs generated for ${newMatches.length} matches`
        });

        showNotification(`Swiss pairs generated: ${newMatches.length} new matches`, 'success');
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        // Load saved theme
        const savedTheme = localStorage.getItem('meijin-theme') || 'dark';
        document.body.setAttribute('data-theme', savedTheme);
        document.getElementById('themeIcon').textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        
        // Initialize search
        document.getElementById('searchPlayers').addEventListener('input', () => filterPlayers('all'));
        
        showNotification('Meijin Go System loaded successfully', 'success');
    });

    // Expose functions to global scope
    window.toggleTheme = toggleTheme;
    window.loginAdmin = loginAdmin;
    window.logoutAdmin = logoutAdmin;
    window.addNewPlayer = addNewPlayer;
    window.startNewTournament = startNewTournament;
    window.createManualMatch = createManualMatch;
    window.setMatchWinner = setMatchWinner;
    window.endTournament = endTournament;
    window.generateSwissPairs = generateSwissPairs;
    window.clearCurrentMatches = clearCurrentMatches;
    window.selectAllPlayers = selectAllPlayers;
    window.deselectAllPlayers = deselectAllPlayers;
    window.filterPlayers = filterPlayers;
</script>
</body>
</html>
