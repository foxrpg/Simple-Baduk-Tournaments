<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meijin Go System - Pro Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Serif+JP:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* Styles existants... (inchang√©s) */
        :root {
            --primary-dark: #1a1a2e;
            --primary: #162447;
            --secondary: #1f4068;
            --accent: #e43f5a;
            --accent-light: #ff6b8b;
            --success: #2ecc71;
            --success-light: #4cd97b;
            --warning: #f39c12;
            --danger: #e74c3c;
            --gold: #ffd700;
            --silver: #c0c0c0;
            --bronze: #cd7f32;
            --stone-black: #000000;
            --stone-white: #ffffff;
            --goban-light: #dcb35c;
            --goban-dark: #5d4037;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --bg-light: #f8f9fa;
            --bg-card: #ffffff;
            --border: #e0e0e0;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            --shadow-hover: 0 8px 30px rgba(0, 0, 0, 0.12);
            --radius-lg: 16px;
            --radius-md: 12px;
            --radius-sm: 8px;
        }

        [data-theme="dark"] {
            --primary-dark: #0d1117;
            --primary: #161b22;
            --secondary: #21262d;
            --accent: #ff7b72;
            --accent-light: #ffa198;
            --success: #238636;
            --success-light: #2ea043;
            --warning: #d29922;
            --danger: #f85149;
            --gold: #ffd700;
            --silver: #c0c0c0;
            --bronze: #cd7f32;
            --stone-black: #000000;
            --stone-white: #ffffff;
            --goban-light: #5d4037;
            --goban-dark: #3e2723;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --bg-light: #0d1117;
            --bg-card: #161b22;
            --border: #30363d;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            --shadow-hover: 0 8px 30px rgba(0, 0, 0, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary) 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            margin-bottom: 30px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--stone-black) 0%, #333 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            font-weight: 700;
        }

        .logo-text {
            font-family: 'Noto Serif JP', serif;
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--gold) 0%, var(--accent-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .theme-toggle {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: var(--radius-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .auth-section {
            display: flex;
            gap: 10px;
        }

        .auth-input {
            padding: 10px 15px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--bg-card);
            color: var(--text-primary);
            min-width: 180px;
        }

        .btn {
            padding: 10px 24px;
            border-radius: var(--radius-md);
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(228, 63, 90, 0.3);
        }

        .btn-secondary {
            background: var(--secondary);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success) 0%, var(--success-light) 100%);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-warning {
            background: var(--warning);
            color: white;
        }

        /* ... (autres styles inchang√©s) ... */

        /* NOUVEAUX STYLES POUR LES AM√âLIORATIONS */

        /* Bouton d'inversion des couleurs */
        .color-controls {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            gap: 10px;
        }

        .swap-colors-global-btn {
            background: var(--warning);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--radius-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .swap-colors-global-btn:hover {
            background: #e67e22;
            transform: rotate(5deg);
        }

        /* Gestion manuelle avanc√©e */
        .advanced-match-controls {
            background: linear-gradient(135deg, rgba(31, 64, 104, 0.1) 0%, transparent 100%);
            border-radius: var(--radius-md);
            padding: 20px;
            margin: 20px 0;
            border: 1px solid var(--border);
        }

        .advanced-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .advanced-control-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .advanced-control-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Historique d√©taill√© */
        .history-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-md);
            margin-top: 15px;
        }

        .history-details.expanded {
            max-height: 500px;
            padding: 15px;
            border: 1px solid var(--border);
        }

        .history-details-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .history-details-table th {
            text-align: left;
            padding: 8px 12px;
            background: var(--bg-light);
            color: var(--text-primary);
            font-weight: 600;
            border-bottom: 2px solid var(--border);
        }

        .history-details-table td {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            color: var(--text-secondary);
        }

        .history-details-table tr:hover {
            background: rgba(228, 63, 90, 0.05);
        }

        /* Gestion manuelle des joueurs dans les matchs */
        .player-select-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 15px 0;
        }

        .player-select-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
        }

        .swap-players-btn {
            background: var(--secondary);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .swap-players-btn:hover {
            transform: rotate(180deg);
            background: var(--primary);
        }

        /* Boutons d'action rapide */
        .quick-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .quick-action-btn {
            padding: 8px 15px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-primary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .quick-action-btn:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        /* Statut des matchs */
        .match-status-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 10px;
        }

        .match-status-pending {
            background: var(--warning);
            color: var(--primary-dark);
        }

        .match-status-completed {
            background: var(--success);
            color: white;
        }

        .match-status-cancelled {
            background: var(--danger);
            color: white;
        }

        /* Contr√¥les de couleur am√©lior√©s */
        .stone-display.swappable {
            cursor: pointer;
            position: relative;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .stone-display.swappable:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        .stone-display.swappable:hover::after {
            content: '‚Üª';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        /* Am√©liorations de l'historique */
        .history-expand-btn {
            background: none;
            border: none;
            color: var(--accent);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            border-radius: var(--radius-sm);
            transition: all 0.3s ease;
        }

        .history-expand-btn:hover {
            background: rgba(228, 63, 90, 0.1);
        }

        /* Boutons d'action dans l'historique */
        .history-actions {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        /* Filtres pour l'historique */
        .history-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .history-filter {
            padding: 6px 12px;
            border-radius: 20px;
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .history-filter:hover,
        .history-filter.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        /* Styles pour les matchs individuels */
        .match-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        .match-result-select {
            width: 100%;
            padding: 8px 12px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--bg-light);
            color: var(--text-primary);
        }

        /* Media queries pour la responsivit√© */
        @media (max-width: 768px) {
            .advanced-controls-grid {
                grid-template-columns: 1fr;
            }
            
            .player-select-row {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .swap-players-btn {
                transform: rotate(90deg);
                margin: 0 auto;
            }
            
            .quick-actions {
                justify-content: center;
            }
            
            .history-details-table {
                display: block;
                overflow-x: auto;
            }
        }

        /* Animation pour les changements de couleur */
        @keyframes colorSwap {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .color-swap-animation {
            animation: colorSwap 0.5s ease;
        }

        /* Indicateur de gestion manuelle */
        .manual-control-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 3px 8px;
            background: var(--warning);
            color: var(--primary-dark);
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 10px;
        }

        /* Statistiques d√©taill√©es de l'historique */
        .history-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .history-stat-item {
            background: var(--bg-light);
            border-radius: var(--radius-md);
            padding: 12px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .history-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 5px;
        }

        .history-stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
<div class="container">
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <div class="logo-icon">Á¢Å</div>
            <h1 class="logo-text">Meijin System</h1>
        </div>
        <div class="header-controls">
            <button onclick="toggleTheme()" class="theme-toggle">
                <span id="themeIcon">üåô</span> Theme
            </button>
            <div class="auth-section" id="authSection">
                <input type="password" id="adminPin" class="auth-input" placeholder="Admin PIN">
                <button onclick="loginAdmin()" class="btn btn-primary">Login</button>
            </div>
            <div id="adminControls" style="display: none;">
                <span style="margin-right: 15px; font-weight: 600; color: var(--accent);">Admin Mode</span>
                <button onclick="logoutAdmin()" class="btn btn-danger">Logout</button>
            </div>
        </div>
    </div>

    <!-- Game Format Banner -->
    <div class="format-banner">
        <div class="format-title">
            <span>üéÆ Game Format</span>
        </div>
        <div class="format-details">
            <div class="format-item">Fischer 45min + 15s increment</div>
            <div class="format-item">6.5 points komi</div>
            <div class="format-item">Tournaments 1-3: Swiss System</div>
            <div class="format-item">Tournament 4: Single Elimination</div>
            <div class="format-item">Top 2 after 3 tournaments auto-qualify</div>
        </div>
    </div>

    <!-- Champion Section -->
    <div id="championSection" class="champion-section">
        <div class="champion-title">CURRENT MEIJIN CHAMPION</div>
        <h1 id="currentChampion" class="champion-name">---</h1>
        <div class="season-info">
            <div class="season-item">
                <div class="season-value" id="currentSeason">1</div>
                <div class="season-label">Season</div>
            </div>
            <div class="season-item">
                <div class="season-value" id="tournamentInSeason">1/4</div>
                <div class="season-label">Tournament</div>
            </div>
            <div class="season-item">
                <div class="season-value" id="nextQualifiers">--</div>
                <div class="season-label">Auto-qualifiers</div>
            </div>
        </div>
    </div>

    <!-- Main Grid -->
    <div class="main-grid">
        <!-- Left Column -->
        <aside>
            <!-- Rankings Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üèÜ Global Rankings</h2>
                </div>

                <!-- Add Player Form (Admin Only) -->
                <div id="addPlayerForm" class="add-player-form">
                    <div class="form-grid">
                        <div>
                            <input type="text" id="newPlayerName" class="form-input" placeholder="Player name">
                        </div>
                        <div>
                            <select id="newPlayerRank" class="form-input">
                                <option value="30k">30k</option>
                                <option value="20k">20k</option>
                                <option value="10k">10k</option>
                                <option value="5k">5k</option>
                                <option value="1k" selected>1k</option>
                                <option value="1d">1d</option>
                                <option value="5d">5d</option>
                                <option value="9d">9d</option>
                            </select>
                        </div>
                        <div>
                            <button onclick="addNewPlayer()" class="btn btn-primary">Add</button>
                        </div>
                    </div>
                </div>

                <!-- Search and Filter -->
                <div class="rankings-header">
                    <div class="search-box">
                        <span class="search-icon">üîç</span>
                        <input type="text" id="searchPlayers" class="search-input" placeholder="Search players...">
                    </div>
                </div>

                <div class="filter-buttons">
                    <button onclick="filterPlayers('all')" class="filter-btn active">All</button>
                    <button onclick="filterPlayers('kyu')" class="filter-btn">Kyu (30k-1k)</button>
                    <button onclick="filterPlayers('dan')" class="filter-btn">Dan (1d-9d)</button>
                    <button onclick="filterPlayers('low')" class="filter-btn">30k-10k</button>
                    <button onclick="filterPlayers('mid')" class="filter-btn">5k-1d</button>
                    <button onclick="filterPlayers('high')" class="filter-btn">5d-9d</button>
                </div>

                <!-- Rankings List -->
                <div class="player-list" id="rankingsList">
                    <!-- Players will be listed here -->
                </div>
            </div>

            <!-- Statistics Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìä Statistics</h2>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalPlayers">0</div>
                        <div class="stat-label">Total Players</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalMatches">0</div>
                        <div class="stat-label">Total Matches</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgElo">1500</div>
                        <div class="stat-label">Avg Elo</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="winRate">0%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                </div>
            </div>

            <!-- Chart Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìà Points Evolution</h2>
                </div>
                <div class="chart-container">
                    <canvas id="seasonChart"></canvas>
                </div>
            </div>
        </aside>

        <!-- Middle Column -->
        <main>
            <!-- Tabs for Active/History -->
            <div class="tabs" id="tournamentTabs">
                <button class="tab active" onclick="switchTab('active')">üéØ Active Tournament</button>
                <button class="tab" onclick="switchTab('history')">üìú Tournament History</button>
                <button class="tab" onclick="switchTab('manual')">üõ†Ô∏è Manual Management</button>
            </div>

            <!-- Active Tournament -->
            <div id="activeTournamentCard" class="tab-content active">
                <div class="card">
                    <div class="tournament-header">
                        <div>
                            <h2 id="tournamentTitle" class="tournament-title">Active Tournament</h2>
                            <div class="tournament-meta">
                                <span>Round: <span id="currentRound">1</span>/<span id="totalRounds">3</span></span>
                                <span>Players: <span id="tournamentPlayerCount">0</span></span>
                                <span id="tournamentTypeBadge" class="tournament-type">
                                    <span id="tournamentTypeIcon">‚ôüÔ∏è</span>
                                    <span id="tournamentTypeText">Swiss System</span>
                                </span>
                            </div>
                        </div>
                        <div class="tournament-controls">
                            <button onclick="generateSwissPairs()" class="btn btn-secondary">
                                <span>üîÄ</span> Generate Pairs
                            </button>
                            <button onclick="clearCurrentMatches()" class="btn btn-warning">
                                <span>üîÑ</span> Next Round
                            </button>
                            <button onclick="endTournament()" class="btn btn-danger">
                                <span>üèÅ</span> End Tournament
                            </button>
                        </div>
                    </div>

                    <!-- NOUVEAU: Bouton d'inversion des couleurs global -->
                    <div class="color-controls" id="globalColorControls">
                        <button onclick="swapAllMatchColors()" class="swap-colors-global-btn">
                            <span>üé®</span> Swap All Colors
                        </button>
                        <button onclick="randomizeAllColors()" class="swap-colors-global-btn">
                            <span>üé≤</span> Randomize Colors
                        </button>
                    </div>

                    <!-- Tournament Settings -->
                    <div id="tournamentSettings" class="tournament-settings">
                        <div class="pairing-title">‚öôÔ∏è Tournament Settings</div>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <label class="setting-label">Number of Rounds:</label>
                                <input type="number" id="roundsCount" class="form-input" value="3" min="1" max="10">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Points per Win:</label>
                                <input type="number" id="pointsPerWin" class="form-input" value="10" min="1" max="100">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Points per Loss:</label>
                                <input type="number" id="pointsPerLoss" class="form-input" value="-5" min="-100" max="0">
                            </div>
                        </div>
                    </div>

                    <!-- Manual Pairing avec am√©liorations -->
                    <div id="manualPairingSection" class="pairing-section">
                        <div class="pairing-title">üîß Manual Pairing</div>
                        <div class="player-select-controls">
                            <div class="player-select-row">
                                <select id="player1Select" class="form-input">
                                    <option value="">Select player 1</option>
                                </select>
                                <button onclick="swapSelectedPlayers()" class="swap-players-btn">
                                    ‚áÑ
                                </button>
                                <select id="player2Select" class="form-input">
                                    <option value="">Select player 2</option>
                                </select>
                            </div>
                            <!-- Contr√¥les de couleur pour le match manuel -->
                            <div style="display: flex; gap: 10px; align-items: center; justify-content: center;">
                                <label style="display: flex; align-items: center; gap: 5px;">
                                    <input type="radio" id="manualBlack1" name="manualColor" value="player1" checked>
                                    <span>Player 1 is Black</span>
                                </label>
                                <button onclick="toggleManualColor()" class="swap-colors-global-btn" style="padding: 5px 10px;">
                                    ‚Üª Swap
                                </button>
                                <label style="display: flex; align-items: center; gap: 5px;">
                                    <input type="radio" id="manualBlack2" name="manualColor" value="player2">
                                    <span>Player 2 is Black</span>
                                </label>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 15px;">
                            <button onclick="createManualMatch()" class="btn btn-success" style="flex: 1;">
                                <span>‚ûï</span> Create Match
                            </button>
                            <button onclick="createMultipleMatches()" class="btn btn-secondary" style="flex: 1;">
                                <span>üìã</span> Create Multiple
                            </button>
                        </div>
                    </div>

                    <!-- Gestion manuelle avanc√©e (NOUVEAU) -->
                    <div class="advanced-match-controls">
                        <div class="pairing-title">üõ†Ô∏è Advanced Match Management</div>
                        <div class="advanced-controls-grid">
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">
                                    <span>üéØ</span> Force Winner
                                </label>
                                <select id="forceWinnerSelect" class="form-input">
                                    <option value="">Select winner (optional)</option>
                                </select>
                            </div>
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">
                                    <span>üé®</span> Initial Color
                                </label>
                                <select id="forceColorSelect" class="form-input">
                                    <option value="random">Random</option>
                                    <option value="player1">Player 1 Black</option>
                                    <option value="player2">Player 2 Black</option>
                                </select>
                            </div>
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">
                                    <span>üìä</span> Custom Points
                                </label>
                                <input type="number" id="customPoints" class="form-input" placeholder="Default points">
                            </div>
                        </div>
                    </div>

                    <!-- Round Progress -->
                    <div class="round-progress" id="roundProgressSection">
                        <!-- Round progress will be displayed here -->
                    </div>

                    <!-- Matches Zone -->
                    <div class="matches-grid" id="matchesZone">
                        <!-- Matches will be displayed here -->
                    </div>

                    <!-- Tournament Progress -->
                    <div class="progress-container">
                        <div class="progress-header">
                            <span>Tournament Progress</span>
                            <span id="tournamentProgressText">Round 1/3</span>
                        </div>
                        <div class="progress-bar">
                            <div id="tournamentProgressFill" class="progress-fill" style="width: 0%"></div>
                        </div>
                        <div style="text-align: center; margin-top: 10px; font-size: 0.9rem; color: var(--text-secondary);">
                            <span id="matchesCompleted">0</span> matches completed ‚Ä¢ 
                            <span id="totalMatchesEstimate">0</span> total matches estimated
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tournament History -->
            <div id="tournamentHistoryCard" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üìú Tournament History</h2>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">
                            Total: <span id="totalTournaments">0</span> tournaments
                        </div>
                    </div>

                    <!-- Filtres pour l'historique -->
                    <div class="history-filters">
                        <button class="history-filter active" onclick="filterHistory('all')">All</button>
                        <button class="history-filter" onclick="filterHistory('season1')">Season 1</button>
                        <button class="history-filter" onclick="filterHistory('swiss')">Swiss System</button>
                        <button class="history-filter" onclick="filterHistory('elimination')">Elimination</button>
                        <button class="history-filter" onclick="filterHistory('recent')">Recent</button>
                    </div>

                    <!-- Statistiques de l'historique -->
                    <div class="history-stats-grid">
                        <div class="history-stat-item">
                            <div class="history-stat-value" id="historyTotalMatches">0</div>
                            <div class="history-stat-label">Total Matches</div>
                        </div>
                        <div class="history-stat-item">
                            <div class="history-stat-value" id="historyAvgPlayers">0</div>
                            <div class="history-stat-label">Avg Players</div>
                        </div>
                        <div class="history-stat-item">
                            <div class="history-stat-value" id="historyTotalWins">0</div>
                            <div class="history-stat-label">Total Wins</div>
                        </div>
                        <div class="history-stat-item">
                            <div class="history-stat-value" id="historyMostWins">---</div>
                            <div class="history-stat-label">Most Wins</div>
                        </div>
                    </div>

                    <div class="history-grid" id="tournamentHistoryList">
                        <!-- Tournament history will be displayed here -->
                    </div>
                </div>
            </div>

            <!-- NOUVEAU: Onglet de gestion manuelle -->
            <div id="manualManagementCard" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üõ†Ô∏è Manual Match Management</h2>
                        <span class="manual-control-indicator">Advanced Controls</span>
                    </div>

                    <!-- Actions rapides -->
                    <div class="quick-actions">
                        <button onclick="resetAllMatchColors()" class="quick-action-btn">
                            <span>üé®</span> Reset All Colors
                        </button>
                        <button onclick="clearAllMatches()" class="quick-action-btn">
                            <span>üóëÔ∏è</span> Clear All Matches
                        </button>
                        <button onclick="randomizeAllMatches()" class="quick-action-btn">
                            <span>üé≤</span> Randomize All
                        </button>
                        <button onclick="exportTournamentData()" class="quick-action-btn">
                            <span>üì§</span> Export Data
                        </button>
                    </div>

                    <!-- √âdition de match individuel -->
                    <div class="pairing-section">
                        <div class="pairing-title">‚úèÔ∏è Edit Specific Match</div>
                        <div class="advanced-controls-grid">
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">Select Match</label>
                                <select id="editMatchSelect" class="form-input" onchange="loadMatchForEditing()">
                                    <option value="">Select match to edit...</option>
                                </select>
                            </div>
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">Set Result</label>
                                <select id="editMatchResult" class="form-input">
                                    <option value="">Select result...</option>
                                    <option value="player1">Player 1 Wins</option>
                                    <option value="player2">Player 2 Wins</option>
                                    <option value="draw">Draw</option>
                                    <option value="cancelled">Cancelled</option>
                                </select>
                            </div>
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">Swap Players</label>
                                <button onclick="swapMatchPlayers()" class="btn btn-secondary" style="width: 100%;">
                                    ‚áÑ Swap Players
                                </button>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button onclick="saveMatchChanges()" class="btn btn-success" style="flex: 1;">
                                üíæ Save Changes
                            </button>
                            <button onclick="deleteSelectedMatch()" class="btn btn-danger" style="flex: 1;">
                                üóëÔ∏è Delete Match
                            </button>
                        </div>
                    </div>

                    <!-- Gestion en masse -->
                    <div class="pairing-section" style="margin-top: 20px;">
                        <div class="pairing-title">üì¶ Bulk Operations</div>
                        <div class="advanced-controls-grid">
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">
                                    <input type="checkbox" id="bulkSelectAll">
                                    Select All Matches
                                </label>
                                <div style="display: flex; gap: 10px; margin-top: 10px;">
                                    <button onclick="setBulkWinner('player1')" class="quick-action-btn" style="flex: 1;">
                                        Player 1 Wins All
                                    </button>
                                    <button onclick="setBulkWinner('player2')" class="quick-action-btn" style="flex: 1;">
                                        Player 2 Wins All
                                    </button>
                                </div>
                            </div>
                            <div class="advanced-control-item">
                                <label class="advanced-control-label">Apply to Round</label>
                                <select id="bulkRoundSelect" class="form-input">
                                    <option value="all">All Rounds</option>
                                    <option value="current">Current Round Only</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Pr√©visualisation des changements -->
                    <div class="pairing-section" style="margin-top: 20px; display: none;" id="previewChanges">
                        <div class="pairing-title">üëÅÔ∏è Preview Changes</div>
                        <div id="previewContent" style="background: var(--bg-light); padding: 15px; border-radius: var(--radius-md);">
                            <!-- Pr√©visualisation des changements -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tournament Setup -->
            <div id="tournamentSetupCard" class="card">
                <div class="card-header">
                    <h2 class="card-title">üéØ New Tournament</h2>
                    <div style="color: var(--text-secondary); font-size: 0.9rem;">
                        Season: <span id="currentSeasonNum">1</span> ‚Ä¢ Tournament: <span id="nextTournamentNumber">1</span>/4
                    </div>
                </div>

                <div style="margin: 20px 0;">
                    <input type="text" id="tournamentName" class="form-input" placeholder="Tournament name" 
                           style="width: 100%; font-size: 1.1rem; padding: 15px;">
                </div>

                <h3 style="margin-bottom: 15px; color: var(--text-primary);">Select Participants</h3>
                <div id="enrollmentZone" class="enrollment-grid">
                    <!-- Players will be listed here -->
                </div>

                <div class="enrollment-actions">
                    <button onclick="selectAllPlayers()" class="btn btn-secondary" style="flex: 1;">
                        <span>‚úÖ</span> Select All
                    </button>
                    <button onclick="deselectAllPlayers()" class="btn btn-secondary" style="flex: 1;">
                        <span>‚ùå</span> Deselect All
                    </button>
                    <button onclick="startNewTournament()" id="startTournamentBtn" class="btn btn-primary" style="flex: 2;">
                        <span>üöÄ</span> Start Tournament
                    </button>
                </div>
            </div>
        </main>

        <!-- Right Column -->
        <aside>
            <!-- Season Overview -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìÖ Season Overview</h2>
                </div>
                <div id="seasonTimeline">
                    <!-- Season timeline will be displayed here -->
                </div>
                <div style="margin-top: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span>Season Progress</span>
                        <span id="seasonProgressText">0/4</span>
                    </div>
                    <div class="progress-bar">
                        <div id="seasonProgressFill" class="progress-fill" style="width: 0%"></div>
                    </div>
                </div>
            </div>

            <!-- Recent Matches -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">‚ö° Recent Matches</h2>
                </div>
                <div id="recentMatchesList">
                    <!-- Recent matches will be displayed here -->
                </div>
            </div>

            <!-- System Info -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">‚ÑπÔ∏è System Info</h2>
                </div>
                <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.8;">
                    <p>üîπ <strong>Season System:</strong> 4 tournaments per season</p>
                    <p>üîπ <strong>Tournaments 1-3:</strong> Swiss system</p>
                    <p>üîπ <strong>Tournament 4:</strong> Single elimination</p>
                    <p>üîπ <strong>Auto-qualifiers:</strong> Top 2 after 3 tournaments</p>
                    <p>üîπ <strong>Points:</strong> Win: +10, Loss: -5</p>
                    <p>üîπ <strong>Elo System:</strong> K-factor: 32</p>
                </div>
            </div>
        </aside>
    </div>
</div>

<!-- Notification Container -->
<div id="notificationContainer" class="notification-container"></div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, doc, onSnapshot, updateDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyDzse9aVDIAFscTbGs-3Disy2wdRHWPRF0",
        authDomain: "meijin-system.firebaseapp.com",
        projectId: "meijin-system",
        storageBucket: "meijin-system.firebasestorage.app",
        messagingSenderId: "935283801474",
        appId: "1:935283801474:web:4e161bff3b1c6ffb77a39b"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    let state = {
        players: [],
        activeTournament: null,
        tournamentHistory: [],
        season: 1,
        tournamentCount: 0,
        champion: "None",
        autoQualifiers: [],
        lastAction: "System initialized",
        systemSettings: {
            pointsPerWin: 10,
            pointsPerLoss: -5,
            initialElo: 1500,
            eloKFactor: 32,
            roundsPerTournament: 3
        },
        eloRatings: {},
        seasonHistory: []
    };

    let isAdmin = false;
    let chart = null;

    // Theme Management
    function toggleTheme() {
        const currentTheme = document.body.getAttribute('data-theme') || 'light';
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        document.body.setAttribute('data-theme', newTheme);
        localStorage.setItem('meijin-theme', newTheme);
        
        const themeIcon = document.getElementById('themeIcon');
        themeIcon.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        
        if (chart) {
            chart.destroy();
            renderChart();
        }
        
        showNotification(`${newTheme.charAt(0).toUpperCase() + newTheme.slice(1)} theme activated`, 'info');
    }

    // Admin Authentication
    function loginAdmin() {
        const pin = document.getElementById('adminPin').value;
        if (pin === "159753") {
            isAdmin = true;
            document.getElementById('authSection').style.display = 'none';
            document.getElementById('adminControls').style.display = 'flex';
            document.getElementById('addPlayerForm').classList.add('visible');
            document.getElementById('tournamentSettings').style.display = 'block';
            // Afficher les contr√¥les de couleur globale
            document.getElementById('globalColorControls').style.display = 'flex';
            // Afficher l'onglet de gestion manuelle
            document.getElementById('tournamentTabs').innerHTML += `
                <button class="tab" onclick="switchTab('manual')">üõ†Ô∏è Manual Management</button>
            `;
            showNotification('Admin login successful - Advanced controls enabled', 'success');
        } else {
            showNotification('Incorrect PIN', 'error');
        }
    }

    function logoutAdmin() {
        isAdmin = false;
        document.getElementById('authSection').style.display = 'flex';
        document.getElementById('adminControls').style.display = 'none';
        document.getElementById('addPlayerForm').classList.remove('visible');
        document.getElementById('tournamentSettings').style.display = 'none';
        document.getElementById('globalColorControls').style.display = 'none';
        showNotification('Logged out successfully', 'info');
    }

    // Notification System
    function showNotification(message, type = 'info') {
        const container = document.getElementById('notificationContainer');
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = `
            <div style="flex: 1;">${message}</div>
            <button onclick="this.parentElement.remove()" style="background: none; border: none; color: inherit; cursor: pointer; margin-left: 10px; font-size: 1.2rem;">√ó</button>
        `;
        
        container.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentElement) {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => notification.remove(), 300);
            }
        }, 5000);
    }

    // Firebase Initialization
    const systemRef = doc(db, "system", "current");

    onSnapshot(systemRef, (docSnap) => {
        if (docSnap.exists()) {
            const data = docSnap.data();
            state = {
                ...state,
                ...data,
                players: data.players || [],
                activeTournament: data.activeTournament || null,
                tournamentHistory: data.tournamentHistory || [],
                tournamentCount: data.tournamentCount || 0,
                season: data.season || 1,
                champion: data.champion || "None",
                autoQualifiers: data.autoQualifiers || [],
                systemSettings: data.systemSettings || state.systemSettings,
                eloRatings: data.eloRatings || {},
                seasonHistory: data.seasonHistory || []
            };
            
            updateUI();
            updateSeasonInfo();
            updateTournamentHistory();
            updateHistoryStatistics();
        } else {
            setDoc(systemRef, state).catch(console.error);
        }
    });

    // Tab Switching
    function switchTab(tabName) {
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        
        event.target.classList.add('active');
        
        if (tabName === 'active') {
            document.getElementById('activeTournamentCard').classList.add('active');
        } else if (tabName === 'history') {
            document.getElementById('tournamentHistoryCard').classList.add('active');
        } else if (tabName === 'manual') {
            document.getElementById('manualManagementCard').classList.add('active');
        }
    }

    // =================================================================
    // NOUVELLES FONCTIONNALIT√âS AJOUT√âES
    // =================================================================

    // 1. Inversion des couleurs pour tous les matchs
    async function swapAllMatchColors() {
        if (!isAdmin || !state.activeTournament) {
            showNotification('Admin access required', 'error');
            return;
        }

        const currentRound = state.activeTournament.round;
        const updatedMatches = state.activeTournament.matches.map(match => {
            if (match.round === currentRound) {
                return {
                    ...match,
                    player1IsBlack: !match.player1IsBlack
                };
            }
            return match;
        });

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('All colors swapped for current round', 'success');
    }

    // 2. Randomisation des couleurs
    async function randomizeAllColors() {
        if (!isAdmin || !state.activeTournament) {
            showNotification('Admin access required', 'error');
            return;
        }

        const currentRound = state.activeTournament.round;
        const updatedMatches = state.activeTournament.matches.map(match => {
            if (match.round === currentRound) {
                return {
                    ...match,
                    player1IsBlack: Math.random() > 0.5
                };
            }
            return match;
        });

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('All colors randomized', 'success');
    }

    // 3. √âchange des joueurs s√©lectionn√©s
    function swapSelectedPlayers() {
        const player1Select = document.getElementById('player1Select');
        const player2Select = document.getElementById('player2Select');
        
        const tempValue = player1Select.value;
        const tempText = player1Select.options[player1Select.selectedIndex].text;
        
        player1Select.value = player2Select.value;
        player1Select.options[player1Select.selectedIndex].text = player2Select.options[player2Select.selectedIndex].text;
        
        player2Select.value = tempValue;
        player2Select.options[player2Select.selectedIndex].text = tempText;
        
        // Inverser aussi la s√©lection des couleurs
        const player1Black = document.getElementById('manualBlack1').checked;
        document.getElementById('manualBlack1').checked = !player1Black;
        document.getElementById('manualBlack2').checked = player1Black;
    }

    // 4. Toggle des couleurs manuelles
    function toggleManualColor() {
        const player1Black = document.getElementById('manualBlack1').checked;
        document.getElementById('manualBlack1').checked = !player1Black;
        document.getElementById('manualBlack2').checked = player1Black;
    }

    // 5. Cr√©ation de matchs multiples
    async function createMultipleMatches() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const participants = state.activeTournament.participants || [];
        if (participants.length < 2) {
            showNotification('Not enough players', 'error');
            return;
        }

        // Cr√©er des matchs al√©atoires pour les joueurs non appari√©s
        const currentRound = state.activeTournament.round;
        const existingMatches = state.activeTournament.matches.filter(m => m.round === currentRound);
        const pairedPlayers = new Set();
        
        existingMatches.forEach(match => {
            pairedPlayers.add(match.player1.id);
            pairedPlayers.add(match.player2.id);
        });

        const availablePlayers = participants.filter(p => !pairedPlayers.has(p.id));
        const newMatches = [];

        // M√©langer les joueurs disponibles
        const shuffledPlayers = [...availablePlayers].sort(() => Math.random() - 0.5);

        for (let i = 0; i < shuffledPlayers.length - 1; i += 2) {
            const newMatch = {
                id: Date.now() + Math.random(),
                player1: shuffledPlayers[i],
                player2: shuffledPlayers[i + 1],
                winner: null,
                round: currentRound,
                player1IsBlack: Math.random() > 0.5,
                createdAt: new Date().toISOString()
            };
            newMatches.push(newMatch);
        }

        if (newMatches.length > 0) {
            const updatedMatches = [...state.activeTournament.matches, ...newMatches];
            await updateDoc(systemRef, { 
                "activeTournament.matches": updatedMatches
            });
            
            showNotification(`Created ${newMatches.length} new matches`, 'success');
        } else {
            showNotification('No new matches could be created', 'info');
        }
    }

    // 6. Filtrage de l'historique
    function filterHistory(filterType) {
        document.querySelectorAll('.history-filter').forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
        
        // Cette fonction sera compl√©t√©e avec la logique de filtrage
        showNotification(`Filtering history: ${filterType}`, 'info');
    }

    // 7. Statistiques de l'historique
    function updateHistoryStatistics() {
        const totalMatches = state.tournamentHistory.reduce((sum, t) => sum + (t.matches?.length || 0), 0);
        const avgPlayers = state.tournamentHistory.length > 0 
            ? Math.round(state.tournamentHistory.reduce((sum, t) => sum + (t.participants?.length || 0), 0) / state.tournamentHistory.length)
            : 0;
        
        // Compter les victoires par joueur
        const winCounts = {};
        state.tournamentHistory.forEach(tournament => {
            tournament.matches?.forEach(match => {
                if (match.winner) {
                    winCounts[match.winner] = (winCounts[match.winner] || 0) + 1;
                }
            });
        });
        
        let mostWinsPlayer = '---';
        let mostWinsCount = 0;
        
        Object.entries(winCounts).forEach(([playerId, count]) => {
            if (count > mostWinsCount) {
                const player = state.players.find(p => p.id === playerId);
                if (player) {
                    mostWinsPlayer = player.name.substring(0, 10);
                    mostWinsCount = count;
                }
            }
        });
        
        document.getElementById('historyTotalMatches').textContent = totalMatches;
        document.getElementById('historyAvgPlayers').textContent = avgPlayers;
        document.getElementById('historyTotalWins').textContent = Object.values(winCounts).reduce((a, b) => a + b, 0);
        document.getElementById('historyMostWins').textContent = mostWinsPlayer;
    }

    // 8. Gestion manuelle avanc√©e
    async function resetAllMatchColors() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const updatedMatches = state.activeTournament.matches.map(match => ({
            ...match,
            player1IsBlack: true // Par d√©faut, le joueur 1 a les noirs
        }));

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('All colors reset to default', 'success');
    }

    async function clearAllMatches() {
        if (!isAdmin || !confirm('Clear all matches in current round?')) {
            return;
        }

        const currentRound = state.activeTournament.round;
        const updatedMatches = state.activeTournament.matches.filter(match => match.round !== currentRound);

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('All matches cleared for current round', 'success');
    }

    async function randomizeAllMatches() {
        if (!isAdmin || !confirm('Randomize all matches in current round?')) {
            return;
        }

        const currentRound = state.activeTournament.round;
        const participants = state.activeTournament.participants || [];
        const shuffledParticipants = [...participants].sort(() => Math.random() - 0.5);
        
        const newMatches = [];
        for (let i = 0; i < shuffledParticipants.length - 1; i += 2) {
            newMatches.push({
                id: Date.now() + Math.random(),
                player1: shuffledParticipants[i],
                player2: shuffledParticipants[i + 1],
                winner: null,
                round: currentRound,
                player1IsBlack: Math.random() > 0.5,
                createdAt: new Date().toISOString()
            });
        }

        // Supprimer les anciens matchs du round courant
        const filteredMatches = state.activeTournament.matches.filter(m => m.round !== currentRound);
        const updatedMatches = [...filteredMatches, ...newMatches];

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification(`Randomized ${newMatches.length} matches`, 'success');
    }

    function exportTournamentData() {
        const data = {
            tournament: state.activeTournament,
            exportDate: new Date().toISOString(),
            players: state.activeTournament?.participants || []
        };
        
        const dataStr = JSON.stringify(data, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportFileDefaultName = `meijin-tournament-${new Date().toISOString().split('T')[0]}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
        
        showNotification('Tournament data exported', 'success');
    }

    // 9. Chargement des matchs pour √©dition
    function loadMatchForEditing() {
        const matchId = document.getElementById('editMatchSelect').value;
        if (!matchId) return;
        
        const match = state.activeTournament.matches.find(m => m.id === matchId);
        if (match) {
            // Pr√©-remplir les champs d'√©dition
            document.getElementById('editMatchResult').value = match.winner || '';
            
            showNotification(`Loaded match: ${match.player1.name} vs ${match.player2.name}`, 'info');
        }
    }

    // 10. √âchange des joueurs dans un match sp√©cifique
    async function swapMatchPlayers() {
        const matchId = document.getElementById('editMatchSelect').value;
        if (!matchId) {
            showNotification('Select a match first', 'error');
            return;
        }

        const updatedMatches = state.activeTournament.matches.map(match => {
            if (match.id === matchId) {
                return {
                    ...match,
                    player1: match.player2,
                    player2: match.player1,
                    player1IsBlack: !match.player1IsBlack,
                    winner: match.winner === match.player1.id ? match.player2.id : 
                           match.winner === match.player2.id ? match.player1.id : 
                           match.winner
                };
            }
            return match;
        });

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('Players swapped in selected match', 'success');
    }

    // 11. Sauvegarde des modifications d'un match
    async function saveMatchChanges() {
        const matchId = document.getElementById('editMatchSelect').value;
        const result = document.getElementById('editMatchResult').value;
        
        if (!matchId) {
            showNotification('Select a match first', 'error');
            return;
        }

        const match = state.activeTournament.matches.find(m => m.id === matchId);
        if (!match) return;

        let updatedMatch = { ...match };
        
        // Mettre √† jour le r√©sultat
        if (result) {
            switch(result) {
                case 'player1':
                    updatedMatch.winner = match.player1.id;
                    break;
                case 'player2':
                    updatedMatch.winner = match.player2.id;
                    break;
                case 'draw':
                    updatedMatch.winner = 'draw';
                    break;
                case 'cancelled':
                    updatedMatch.winner = null;
                    updatedMatch.cancelled = true;
                    break;
            }
            
            if (result !== 'cancelled' && result !== 'draw') {
                // Calculer les changements Elo
                const winnerId = result === 'player1' ? match.player1.id : match.player2.id;
                const loserId = result === 'player1' ? match.player2.id : match.player1.id;
                
                const winnerElo = state.eloRatings[winnerId] || state.systemSettings.initialElo;
                const loserElo = state.eloRatings[loserId] || state.systemSettings.initialElo;
                const eloChanges = calculateElo(winnerElo, loserElo, state.systemSettings.eloKFactor);
                
                updatedMatch.eloChanges = {
                    winner: { from: winnerElo, to: eloChanges.newWinnerElo },
                    loser: { from: loserElo, to: eloChanges.newLoserElo }
                };
            }
        }

        const updatedMatches = state.activeTournament.matches.map(m => 
            m.id === matchId ? updatedMatch : m
        );

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('Match updated successfully', 'success');
    }

    // 12. Suppression d'un match
    async function deleteSelectedMatch() {
        const matchId = document.getElementById('editMatchSelect').value;
        if (!matchId || !confirm('Delete this match?')) {
            return;
        }

        const updatedMatches = state.activeTournament.matches.filter(m => m.id !== matchId);
        
        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        // R√©initialiser les s√©lections
        document.getElementById('editMatchSelect').value = '';
        document.getElementById('editMatchResult').value = '';
        
        showNotification('Match deleted', 'success');
    }

    // 13. Op√©rations en masse
    async function setBulkWinner(winnerType) {
        if (!isAdmin || !confirm(`Set all matches to ${winnerType === 'player1' ? 'Player 1 wins' : 'Player 2 wins'}?`)) {
            return;
        }

        const currentRound = state.activeTournament.round;
        const roundFilter = document.getElementById('bulkRoundSelect').value;
        
        const updatedMatches = state.activeTournament.matches.map(match => {
            const matchInRound = match.round === currentRound;
            const applyToMatch = roundFilter === 'all' || (roundFilter === 'current' && matchInRound);
            
            if (applyToMatch && !match.winner) {
                return {
                    ...match,
                    winner: winnerType === 'player1' ? match.player1.id : match.player2.id
                };
            }
            return match;
        });

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        showNotification('Bulk operation completed', 'success');
    }

    // =================================================================
    // FONCTIONS EXISTANTES (modifi√©es si n√©cessaire)
    // =================================================================

    // Elo Rating System
    function calculateElo(winnerElo, loserElo, kFactor = 32) {
        const expectedScoreWinner = 1 / (1 + Math.pow(10, (loserElo - winnerElo) / 400));
        const newWinnerElo = Math.round(winnerElo + kFactor * (1 - expectedScoreWinner));
        const newLoserElo = Math.round(loserElo + kFactor * (0 - (1 - expectedScoreWinner)));
        
        return { newWinnerElo, newLoserElo };
    }

    // Auto Qualifiers Logic
    function updateAutoQualifiers() {
        const sortedPlayers = [...state.players].sort((a, b) => {
            if (a.elo !== undefined && b.elo !== undefined) {
                return b.elo - a.elo;
            }
            return (b.points || 0) - (a.points || 0);
        });
        
        const tournamentInSeason = (state.tournamentCount % 4) + 1;
        document.getElementById('tournamentInSeason').textContent = `${tournamentInSeason}/4`;
        
        // Show auto qualifiers only after 3 tournaments in a season
        if (tournamentInSeason >= 3) {
            const qualifiers = sortedPlayers.slice(0, 2).map(p => p.name);
            
            document.getElementById('nextQualifiers').textContent = qualifiers[0] && qualifiers[1] ? 
                `${qualifiers[0].substring(0, 10)} & ${qualifiers[1].substring(0, 10)}` : '--';
            
            // Update state with auto qualifiers
            if (JSON.stringify(state.autoQualifiers) !== JSON.stringify(qualifiers)) {
                state.autoQualifiers = qualifiers;
                updateDoc(systemRef, { autoQualifiers: qualifiers });
            }
        } else {
            document.getElementById('nextQualifiers').textContent = '--';
        }
    }

    // Player Management
    async function addNewPlayer() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const name = document.getElementById('newPlayerName').value.trim();
        const rank = document.getElementById('newPlayerRank').value;

        if (!name) {
            showNotification('Please enter a name', 'error');
            return;
        }

        if (state.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
            showNotification('Player already exists', 'error');
            return;
        }

        const newPlayer = {
            id: Date.now().toString(),
            name,
            rank,
            points: 0,
            wins: 0,
            losses: 0,
            draws: 0,
            elo: state.systemSettings.initialElo,
            history: [0],
            joinedDate: new Date().toISOString(),
            tournamentsPlayed: 0
        };

        const updatedPlayers = [...state.players, newPlayer];
        const updatedEloRatings = {
            ...state.eloRatings,
            [newPlayer.id]: state.systemSettings.initialElo
        };
        
        await updateDoc(systemRef, { 
            players: updatedPlayers,
            eloRatings: updatedEloRatings
        });
        
        document.getElementById('newPlayerName').value = '';
        showNotification(`Player "${name}" added successfully`, 'success');
    }

    // Tournament Management
    async function startNewTournament() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const name = document.getElementById('tournamentName').value.trim() || 
                     `Season ${state.season} - Tournament ${(state.tournamentCount % 4) + 1}`;
        const enrolled = Array.from(document.querySelectorAll('.enroll-check:checked')).map(cb => cb.value);

        if (enrolled.length < 2) {
            showNotification('Select at least 2 players', 'error');
            return;
        }

        const participants = state.players.filter(p => enrolled.includes(p.id));
        
        // Determine tournament type based on position in season
        const tournamentInSeason = (state.tournamentCount % 4) + 1;
        const tournamentType = tournamentInSeason === 4 ? 'single-elimination' : 'swiss';
        
        // Get rounds count from settings
        const roundsCount = parseInt(document.getElementById('roundsCount').value) || 3;
        
        const tournament = {
            id: Date.now().toString(),
            name,
            participants,
            matches: [],
            startTime: new Date().toISOString(),
            status: 'active',
            round: 1,
            totalRounds: roundsCount,
            type: tournamentType,
            settings: {
                pointsPerWin: parseInt(document.getElementById('pointsPerWin').value) || 10,
                pointsPerLoss: parseInt(document.getElementById('pointsPerLoss').value) || -5
            },
            roundProgress: Array(roundsCount).fill(0).map((_, i) => ({
                round: i + 1,
                completedMatches: 0,
                totalMatches: 0
            })),
            seedings: participants.map(p => ({ 
                id: p.id, 
                seed: (state.eloRatings[p.id] || state.systemSettings.initialElo) + Math.random() 
            })).sort((a, b) => b.seed - a.seed)
        };

        // Calculate estimated matches per round
        tournament.roundProgress.forEach(round => {
            round.totalMatches = Math.floor(participants.length / 2);
        });

        await updateDoc(systemRef, { 
            activeTournament: tournament,
            lastAction: `üéØ Tournament "${name}" started with ${participants.length} players`
        });

        showNotification(`Tournament "${name}" started!`, 'success');
    }

    async function createManualMatch() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const p1Id = document.getElementById('player1Select').value;
        const p2Id = document.getElementById('player2Select').value;

        if (!p1Id || !p2Id) {
            showNotification('Select two players', 'error');
            return;
        }

        if (p1Id === p2Id) {
            showNotification('Player cannot play against themselves', 'error');
            return;
        }

        const p1 = state.activeTournament.participants.find(p => p.id === p1Id);
        const p2 = state.activeTournament.participants.find(p => p.id === p2Id);

        // Check for duplicate match in current round
        const existingMatch = state.activeTournament.matches.find(m => 
            ((m.player1.id === p1Id && m.player2.id === p2Id) ||
            (m.player1.id === p2Id && m.player2.id === p1Id)) &&
            m.round === state.activeTournament.round
        );

        if (existingMatch) {
            showNotification('Match already exists in this round', 'error');
            return;
        }

        // D√©terminer qui a les noirs
        const player1IsBlack = document.getElementById('manualBlack1').checked;

        const newMatch = {
            id: Date.now().toString(),
            player1: p1,
            player2: p2,
            winner: null,
            round: state.activeTournament.round,
            player1IsBlack: player1IsBlack,
            createdAt: new Date().toISOString()
        };

        const updatedMatches = [...state.activeTournament.matches, newMatch];
        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches,
            lastAction: `‚öîÔ∏è New match: ${p1.name} (${player1IsBlack ? 'Black' : 'White'}) vs ${p2.name} (${!player1IsBlack ? 'Black' : 'White'})`
        });
        
        showNotification('Match created successfully', 'success');
    }

    // Swap colors function - AM√âLIOR√âE
    async function swapMatchColors(matchId) {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const updatedMatches = state.activeTournament.matches.map(match => {
            if (match.id === matchId) {
                return {
                    ...match,
                    player1IsBlack: !match.player1IsBlack
                };
            }
            return match;
        });

        await updateDoc(systemRef, { 
            "activeTournament.matches": updatedMatches
        });
        
        // Animation visuelle
        const stoneDisplay = document.querySelector(`.match-card [data-match-id="${matchId}"] .stone-display`);
        if (stoneDisplay) {
            stoneDisplay.classList.add('color-swap-animation');
            setTimeout(() => stoneDisplay.classList.remove('color-swap-animation'), 500);
        }
        
        showNotification('Colors swapped', 'info');
    }

    async function setMatchWinner(matchId, winnerId) {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        const match = state.activeTournament.matches.find(m => m.id === matchId);
        const loserId = winnerId === match.player1.id ? match.player2.id : match.player1.id;
        
        const winner = state.players.find(p => p.id === winnerId);
        const loser = state.players.find(p => p.id === loserId);

        // Calculate Elo changes
        const winnerElo = state.eloRatings[winnerId] || state.systemSettings.initialElo;
        const loserElo = state.eloRatings[loserId] || state.systemSettings.initialElo;
        const eloChanges = calculateElo(winnerElo, loserElo, state.systemSettings.eloKFactor);
        
        // Update Elo ratings
        const updatedEloRatings = {
            ...state.eloRatings,
            [winnerId]: eloChanges.newWinnerElo,
            [loserId]: eloChanges.newLoserElo
        };

        // Update players
        const updatedPlayers = state.players.map(p => {
            if (p.id === winnerId) {
                return {
                    ...p,
                    points: (p.points || 0) + state.activeTournament.settings.pointsPerWin,
                    wins: (p.wins || 0) + 1,
                    elo: eloChanges.newWinnerElo,
                    history: [...(p.history || [0]), (p.points || 0) + state.activeTournament.settings.pointsPerWin],
                    tournamentsPlayed: (p.tournamentsPlayed || 0) + (state.activeTournament.matches.filter(m => m.winner === p.id).length === 0 ? 1 : 0)
                };
            }
            if (p.id === loserId) {
                return {
                    ...p,
                    points: Math.max(0, (p.points || 0) + state.activeTournament.settings.pointsPerLoss),
                    losses: (p.losses || 0) + 1,
                    elo: eloChanges.newLoserElo,
                    history: [...(p.history || [0]), Math.max(0, (p.points || 0) + state.activeTournament.settings.pointsPerLoss)],
                    tournamentsPlayed: (p.tournamentsPlayed || 0) + (state.activeTournament.matches.filter(m => 
                        (m.player1.id === p.id || m.player2.id === p.id) && m.winner
                    ).length === 0 ? 1 : 0)
                };
            }
            return p;
        });

        // Update match
        const updatedMatches = state.activeTournament.matches.map(m => 
            m.id === matchId ? { 
                ...m, 
                winner: winnerId,
                eloChanges: {
                    winner: { from: winnerElo, to: eloChanges.newWinnerElo },
                    loser: { from: loserElo, to: eloChanges.newLoserElo }
                },
                endedAt: new Date().toISOString()
            } : m
        );

        // Update round progress
        const currentRound = state.activeTournament.round;
        const roundProgress = [...state.activeTournament.roundProgress];
        const roundIndex = currentRound - 1;
        
        if (roundIndex >= 0 && roundIndex < roundProgress.length) {
            const completedMatches = updatedMatches.filter(m => 
                m.round === currentRound && m.winner
            ).length;
            
            roundProgress[roundIndex] = {
                ...roundProgress[roundIndex],
                completedMatches: completedMatches
            };
        }

        await updateDoc(systemRef, {
            players: updatedPlayers,
            eloRatings: updatedEloRatings,
            "activeTournament.matches": updatedMatches,
            "activeTournament.roundProgress": roundProgress,
            lastAction: `üèÜ ${winner.name} defeated ${loser.name}! (+${eloChanges.newWinnerElo - winnerElo} Elo)`
        });

        showNotification(`${winner.name} wins! Elo: +${eloChanges.newWinnerElo - winnerElo}`, 'success');
    }

    async function endTournament() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        if (!confirm('End this tournament and update rankings?')) {
            return;
        }

        let updatedTournamentCount = state.tournamentCount + 1;
        let updatedSeason = state.season;
        let updatedChampion = state.champion;
        
        // Calculate tournament results
        const tournamentResults = state.activeTournament.participants.map(p => {
            const wins = state.activeTournament.matches.filter(m => m.winner === p.id).length;
            const losses = state.activeTournament.matches.filter(m => 
                (m.player1.id === p.id || m.player2.id === p.id) && 
                m.winner && 
                m.winner !== p.id
            ).length;
            return { 
                ...p, 
                tournamentWins: wins,
                tournamentLosses: losses,
                tournamentPoints: wins * state.activeTournament.settings.pointsPerWin + losses * state.activeTournament.settings.pointsPerLoss
            };
        }).sort((a, b) => b.tournamentPoints - a.tournamentPoints);

        // Add tournament to history
        const tournamentRecord = {
            ...state.activeTournament,
            endTime: new Date().toISOString(),
            results: tournamentResults.map(r => ({
                playerId: r.id,
                playerName: r.name,
                wins: r.tournamentWins,
                losses: r.tournamentLosses,
                points: r.tournamentPoints
            })),
            winner: tournamentResults[0]?.id || null,
            season: state.season,
            positionInSeason: (state.tournamentCount % 4) + 1
        };

        // Check if season is complete (4 tournaments)
        if (updatedTournamentCount % 4 === 0) {
            updatedSeason += 1;
            
            // Determine season champion (winner of tournament 4)
            if (tournamentResults.length > 0 && tournamentResults[0].tournamentWins > 0) {
                updatedChampion = tournamentResults[0].name;
            }
            
            // Add season to history
            const seasonRecord = {
                season: state.season,
                tournaments: state.tournamentHistory.slice(-3).concat([tournamentRecord]),
                champion: updatedChampion,
                endDate: new Date().toISOString()
            };
            
            const updatedSeasonHistory = [...state.seasonHistory, seasonRecord];
            
            await updateDoc(systemRef, {
                activeTournament: null,
                tournamentHistory: [...state.tournamentHistory, tournamentRecord],
                tournamentCount: updatedTournamentCount,
                season: updatedSeason,
                champion: updatedChampion,
                autoQualifiers: [],
                seasonHistory: updatedSeasonHistory,
                lastAction: `üèÜ Season ${state.season} complete! ${updatedChampion} is the new champion!`
            });
            
            showNotification(`Season ${state.season} complete! New season started.`, 'success');
        } else {
            await updateDoc(systemRef, {
                activeTournament: null,
                tournamentHistory: [...state.tournamentHistory, tournamentRecord],
                tournamentCount: updatedTournamentCount,
                champion: updatedChampion,
                lastAction: `üèÅ Tournament "${state.activeTournament.name}" ended`
            });
            
            showNotification('Tournament ended successfully', 'success');
        }
    }

    // Generate Swiss Pairs
    async function generateSwissPairs() {
        if (!isAdmin || !state.activeTournament) {
            showNotification('Admin access required', 'error');
            return;
        }

        const participants = [...state.activeTournament.participants];
        const currentRound = state.activeTournament.round;
        const existingMatches = state.activeTournament.matches.filter(m => m.round === currentRound);
        
        if (existingMatches.length > 0) {
            if (!confirm('Matches already exist for this round. Generate new pairs anyway?')) {
                return;
            }
        }

        // Calculate current scores for this tournament
        const scores = participants.map(player => {
            const wins = state.activeTournament.matches.filter(m => m.winner === player.id).length;
            const losses = state.activeTournament.matches.filter(m => 
                (m.player1.id === player.id || m.player2.id === player.id) && 
                m.winner && 
                m.winner !== player.id
            ).length;
            
            // Get opponents from previous rounds
            const opponents = state.activeTournament.matches
                .filter(m => (m.player1.id === player.id || m.player2.id === player.id) && m.round < currentRound)
                .map(m => m.player1.id === player.id ? m.player2.id : m.player1.id);
            
            return {
                ...player,
                score: wins,
                losses: losses,
                opponents: new Set(opponents),
                played: opponents.length,
                elo: state.eloRatings[player.id] || state.systemSettings.initialElo
            };
        });

        // Sort by score (wins), then by opponent's strength, then by Elo
        scores.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            if (b.elo !== a.elo) return b.elo - a.elo;
            return a.played - b.played;
        });

        // Generate pairs
        const newMatches = [];
        const paired = new Set();

        for (let i = 0; i < scores.length; i++) {
            if (paired.has(scores[i].id)) continue;

            let bestOpponent = null;
            let bestScoreDiff = Infinity;

            // Find suitable opponent
            for (let j = i + 1; j < scores.length; j++) {
                if (!paired.has(scores[j].id) && !scores[i].opponents.has(scores[j].id)) {
                    const scoreDiff = Math.abs(scores[i].score - scores[j].score);
                    if (scoreDiff < bestScoreDiff) {
                        bestScoreDiff = scoreDiff;
                        bestOpponent = j;
                    }
                }
            }

            // If found suitable opponent
            if (bestOpponent !== null) {
                newMatches.push({
                    id: Date.now() + Math.random(),
                    player1: scores[i],
                    player2: scores[bestOpponent],
                    winner: null,
                    round: currentRound,
                    player1IsBlack: Math.random() > 0.5
                });
                
                paired.add(scores[i].id);
                paired.add(scores[bestOpponent].id);
            } else {
                // If no suitable opponent, pair with closest available
                for (let j = i + 1; j < scores.length; j++) {
                    if (!paired.has(scores[j].id)) {
                        newMatches.push({
                            id: Date.now() + Math.random(),
                            player1: scores[i],
                            player2: scores[j],
                            winner: null,
                            round: currentRound,
                            player1IsBlack: Math.random() > 0.5
                        });
                        
                        paired.add(scores[i].id);
                        paired.add(scores[j].id);
                        break;
                    }
                }
            }
        }

        // Filter out existing matches for this round
        const filteredExistingMatches = state.activeTournament.matches.filter(m => m.round !== currentRound);
        const updatedMatches = [...filteredExistingMatches, ...newMatches];
        
        await updateDoc(systemRef, {
            "activeTournament.matches": updatedMatches,
            lastAction: `üé≤ Swiss pairs generated for round ${currentRound}: ${newMatches.length} matches`
        });

        showNotification(`Generated ${newMatches.length} pairs for round ${currentRound}`, 'success');
    }

    async function clearCurrentMatches() {
        if (!isAdmin) {
            showNotification('Admin access required', 'error');
            return;
        }

        if (state.activeTournament.round >= state.activeTournament.totalRounds) {
            showNotification('Tournament has reached maximum rounds', 'warning');
            return;
        }

        if (confirm('Start next round? This will clear current round matches.')) {
            const nextRound = state.activeTournament.round + 1;
            
            await updateDoc(systemRef, {
                "activeTournament.round": nextRound,
                lastAction: `üîÑ Round ${nextRound} started`
            });
            
            showNotification(`Round ${nextRound} started`, 'info');
        }
    }

    // UI Update Functions avec am√©liorations
    function updateUI() {
        updateRankings();
        updateTournamentView();
        updateStatistics();
        updateRecentMatches();
        updateSeasonTimeline();
        updateRoundProgress();
        renderChart();
        updateSeasonInfo();
        updateEditMatchSelect();
    }

    function updateEditMatchSelect() {
        if (!state.activeTournament) return;
        
        const matchSelect = document.getElementById('editMatchSelect');
        if (!matchSelect) return;
        
        const currentRound = state.activeTournament.round;
        const matchesThisRound = state.activeTournament.matches.filter(m => m.round === currentRound);
        
        matchSelect.innerHTML = '<option value="">Select match to edit...</option>';
        matchesThisRound.forEach(match => {
            const option = document.createElement('option');
            option.value = match.id;
            option.textContent = `${match.player1.name} vs ${match.player2.name}`;
            matchSelect.appendChild(option);
        });
    }

    function updateRoundProgress() {
        if (!state.activeTournament) return;
        
        const roundProgressHTML = state.activeTournament.roundProgress.map((round, index) => {
            const isCurrentRound = index + 1 === state.activeTournament.round;
            const progress = round.totalMatches > 0 ? (round.completedMatches / round.totalMatches) * 100 : 0;
            
            return `
                <div class="round-item ${isCurrentRound ? 'pulse' : ''}" style="${isCurrentRound ? 'border-color: var(--accent);' : ''}">
                    <div class="round-number" style="${isCurrentRound ? 'background: var(--accent);' : ''}">
                        ${index + 1}
                    </div>
                    <div class="round-info">
                        <div class="round-title">Round ${index + 1} ${isCurrentRound ? '(Current)' : ''}</div>
                        <div class="round-stats">
                            <span>${round.completedMatches}/${round.totalMatches} matches</span>
                            <span>${Math.round(progress)}% complete</span>
                        </div>
                        <div class="progress-bar" style="margin-top: 8px; height: 6px;">
                            <div class="progress-fill" style="width: ${progress}%; background: ${isCurrentRound ? 'var(--accent)' : 'var(--secondary)'};"></div>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
        
        document.getElementById('roundProgressSection').innerHTML = roundProgressHTML || 
            '<div class="empty-state">No round data available</div>';
        
        // Update tournament progress
        const totalRounds = state.activeTournament.totalRounds;
        const currentRound = state.activeTournament.round;
        const tournamentProgress = ((currentRound - 1) / totalRounds) * 100;
        
        document.getElementById('tournamentProgressText').textContent = `Round ${currentRound}/${totalRounds}`;
        document.getElementById('tournamentProgressFill').style.width = `${tournamentProgress}%`;
        
        // Update matches statistics
        const totalMatchesPlayed = state.activeTournament.matches.filter(m => m.winner).length;
        const estimatedTotalMatches = Math.floor(state.activeTournament.participants.length / 2) * totalRounds;
        
        document.getElementById('matchesCompleted').textContent = totalMatchesPlayed;
        document.getElementById('totalMatchesEstimate').textContent = estimatedTotalMatches;
    }

    function updateRankings() {
        const sortedPlayers = [...state.players].sort((a, b) => {
            if (a.elo !== undefined && b.elo !== undefined) {
                return b.elo - a.elo;
            }
            return (b.points || 0) - (a.points || 0);
        });
        
        const rankingsHTML = sortedPlayers.map((player, index) => {
            const elo = state.eloRatings[player.id] || state.systemSettings.initialElo;
            const winRate = player.wins + player.losses > 0 
                ? Math.round((player.wins / (player.wins + player.losses)) * 100) 
                : 0;
            
            return `
                <div class="player-item ${index < 3 ? 'top-3' : ''}">
                    <div class="player-rank">${index + 1}</div>
                    <div class="player-info">
                        <div class="player-name">
                            ${player.name}
                            ${index === 0 ? '<span class="badge badge-gold">ü•á</span>' : ''}
                            ${index === 1 ? '<span class="badge badge-silver">ü•à</span>' : ''}
                            ${index === 2 ? '<span class="badge badge-bronze">ü•â</span>' : ''}
                        </div>
                        <div class="player-meta">
                            <span class="player-tag">${player.rank}</span>
                            <span>Elo: ${elo}</span>
                            <span>${player.wins || 0}W ${player.losses || 0}L</span>
                        </div>
                    </div>
                    <div class="player-stats">
                        <div class="player-points">${player.points || 0} pts</div>
                        <div class="player-record">${winRate}% win rate</div>
                    </div>
                </div>
            `;
        }).join('');

        document.getElementById('rankingsList').innerHTML = rankingsHTML || 
            '<div class="empty-state">No players registered yet</div>';
    }

    function updateTournamentView() {
        const tournamentTypeIcon = document.getElementById('tournamentTypeIcon');
        const tournamentTypeText = document.getElementById('tournamentTypeText');
        
        if (state.activeTournament) {
            document.getElementById('activeTournamentCard').style.display = 'block';
            document.getElementById('tournamentSetupCard').style.display = 'none';
            
            document.getElementById('tournamentTitle').textContent = state.activeTournament.name;
            document.getElementById('currentRound').textContent = state.activeTournament.round;
            document.getElementById('totalRounds').textContent = state.activeTournament.totalRounds;
            document.getElementById('tournamentPlayerCount').textContent = state.activeTournament.participants.length;
            
            // Set tournament type display
            if (state.activeTournament.type === 'single-elimination') {
                tournamentTypeIcon.textContent = 'üèÜ';
                tournamentTypeText.textContent = 'Single Elimination';
            } else {
                tournamentTypeIcon.textContent = '‚ôüÔ∏è';
                tournamentTypeText.textContent = 'Swiss System';
            }
            
            // Update tournament settings inputs
            document.getElementById('roundsCount').value = state.activeTournament.totalRounds;
            document.getElementById('pointsPerWin').value = state.activeTournament.settings?.pointsPerWin || 10;
            document.getElementById('pointsPerLoss').value = state.activeTournament.settings?.pointsPerLoss || -5;
            
            // Update player selects with am√©lioration
            const participants = state.activeTournament.participants || [];
            const playerOptions = participants.map(p => 
                `<option value="${p.id}">${p.name} (${p.rank}) - ${state.eloRatings[p.id] || state.systemSettings.initialElo} Elo</option>`
            ).join('');
            
            document.getElementById('player1Select').innerHTML = `<option value="">Select player 1</option>${playerOptions}`;
            document.getElementById('player2Select').innerHTML = `<option value="">Select player 2</option>${playerOptions}`;
            
            // Mettre √† jour le s√©lecteur de forceWinner
            document.getElementById('forceWinnerSelect').innerHTML = `<option value="">Select winner (optional)</option>${playerOptions}`;
            
            // Update matches
            updateMatchesDisplay();
        } else {
            document.getElementById('activeTournamentCard').style.display = 'none';
            document.getElementById('tournamentSetupCard').style.display = 'block';
            
            // Update enrollment zone
            updateEnrollmentZone();
            
            // Update next tournament number
            const nextTournamentNum = (state.tournamentCount % 4) + 1;
            document.getElementById('nextTournamentNumber').textContent = nextTournamentNum;
        }
    }

    function updateMatchesDisplay() {
    if (!state.activeTournament) return;
    
    const currentRound = state.activeTournament.round;
    const matchesThisRound = state.activeTournament.matches.filter(m => m.round === currentRound);
    
    const matchesHTML = matchesThisRound.map(match => {
        const isCompleted = !!match.winner;
        const winnerIsPlayer1 = match.winner === match.player1.id;
        
        return `
            <div class="match-card ${isCompleted ? 'completed' : ''}" data-match-id="${match.id}">
                <div class="match-player ${winnerIsPlayer1 ? 'winner' : ''}">
                    <!-- Bouton d'inversion avec am√©lioration -->
                    ${isAdmin && !isCompleted ? 
                        `<button onclick="swapMatchColors('${match.id}')" 
                                style="position: absolute; top: 10px; right: 10px; background: var(--warning); color: white; border: none; width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 1rem; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(243, 156, 18, 0.3);">
                            ‚Üª
                        </button>` 
                        : ''}
                    
                    <!-- Pierre avec effet hover -->
                    <div class="stone-display swappable ${match.player1IsBlack ? 'black' : 'white'}" 
                         onclick="${isAdmin && !isCompleted ? `swapMatchColors('${match.id}')` : ''}"
                         style="width: 50px; height: 50px; border-radius: 50%; margin: 0 auto 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); background: ${match.player1IsBlack ? 'radial-gradient(circle at 30% 30%, #666, #000)' : 'radial-gradient(circle at 30% 30%, #fff, #f0f0f0)'}; ${!match.player1IsBlack ? 'border: 2px solid #ddd;' : ''}">
                    </div>
                    
                    <div class="player-label">${match.player1.name}</div>
                    <div class="player-subtext">${match.player1.rank} ‚Ä¢ ${state.eloRatings[match.player1.id] || state.systemSettings.initialElo} Elo</div>
                    
                    ${!isCompleted && isAdmin ? 
                        `<div style="display: flex; flex-direction: column; gap: 10px; align-items: center; margin-top: 10px;">
                            <button onclick="setMatchWinner('${match.id}', '${match.player1.id}')" 
                                    style="padding: 10px 20px; border-radius: var(--radius-md); border: none; background: linear-gradient(135deg, var(--success) 0%, var(--success-light) 100%); color: white; font-weight: 600; cursor: pointer; transition: all 0.3s ease; min-width: 120px; text-align: center;">
                                üéØ ${match.player1.name} Wins
                            </button>
                            <button onclick="editMatchManually('${match.id}')" class="quick-action-btn" style="min-width: 120px;">
                                üõ†Ô∏è Edit
                            </button>
                        </div>` : 
                        (winnerIsPlayer1 ? '<div style="background: var(--success); color: white; padding: 5px 10px; border-radius: 20px; font-size: 0.8rem; font-weight: 600; margin-top: 10px;">WINNER</div>' : '')
                    }
                </div>
                
                <div style="text-align: center; font-size: 1.3rem; font-weight: 700; color: var(--accent);">
                    VS
                    ${isCompleted ? `<div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 5px;">Completed</div>` : ''}
                </div>
                
                <div class="match-player ${!winnerIsPlayer1 && isCompleted ? 'winner' : ''}">
                    <!-- Bouton d'inversion -->
                    ${isAdmin && !isCompleted ? 
                        `<button onclick="swapMatchColors('${match.id}')" 
                                style="position: absolute; top: 10px; right: 10px; background: var(--warning); color: white; border: none; width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 1rem; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(243, 156, 18, 0.3);">
                            ‚Üª
                        </button>` 
                        : ''}
                    
                    <!-- Pierre avec effet hover -->
                    <div class="stone-display swappable ${!match.player1IsBlack ? 'black' : 'white'}" 
                         onclick="${isAdmin && !isCompleted ? `swapMatchColors('${match.id}')` : ''}"
                         style="width: 50px; height: 50px; border-radius: 50%; margin: 0 auto 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); background: ${!match.player1IsBlack ? 'radial-gradient(circle at 30% 30%, #666, #000)' : 'radial-gradient(circle at 30% 30%, #fff, #f0f0f0)'}; ${match.player1IsBlack ? 'border: 2px solid #ddd;' : ''}">
                    </div>
                    
                    <div class="player-label">${match.player2.name}</div>
                    <div class="player-subtext">${match.player2.rank} ‚Ä¢ ${state.eloRatings[match.player2.id] || state.systemSettings.initialElo} Elo</div>
                    
                    ${!isCompleted && isAdmin ? 
                        `<div style="display: flex; flex-direction: column; gap: 10px; align-items: center; margin-top: 10px;">
                            <button onclick="setMatchWinner('${match.id}', '${match.player2.id}')" 
                                    style="padding: 10px 20px; border-radius: var(--radius-md); border: none; background: linear-gradient(135deg, var(--success) 0%, var(--success-light) 100%); color: white; font-weight: 600; cursor: pointer; transition: all 0.3s ease; min-width: 120px; text-align: center;">
                                üéØ ${match.player2.name} Wins
                            </button>
                            <button onclick="editMatchManually('${match.id}')" class="quick-action-btn" style="min-width: 120px;">
                                üõ†Ô∏è Edit
                            </button>
                        </div>` : 
                        (!winnerIsPlayer1 && isCompleted ? '<div style="background: var(--success); color: white; padding: 5px 10px; border-radius: 20px; font-size: 0.8rem; font-weight: 600; margin-top: 10px;">WINNER</div>' : '')
                    }
                </div>
            </div>
        `;
    }).join('');
    
    document.getElementById('matchesZone').innerHTML = matchesHTML || 
        '<div class="empty-state">No matches for this round yet</div>';
}
    // Fonction pour √©diter un match manuellement
    function editMatchManually(matchId) {
        // Naviguer vers l'onglet de gestion manuelle
        switchTab('manual');
        
        // S√©lectionner le match dans la liste
        const matchSelect = document.getElementById('editMatchSelect');
        matchSelect.value = matchId;
        
        // Charger les donn√©es du match
        loadMatchForEditing();
    }

    function updateEnrollmentZone() {
        const playersHTML = state.players.map(player => `
            <label class="enrollment-item">
                <input type="checkbox" class="enroll-check" value="${player.id}" checked>
                <span style="font-weight: 600;">${player.name}</span>
                <span style="margin-left: auto; font-size: 0.9rem; color: var(--text-secondary);">
                    ${player.rank} ‚Ä¢ ${state.eloRatings[player.id] || state.systemSettings.initialElo} Elo
                </span>
            </label>
        `).join('');
        
        document.getElementById('enrollmentZone').innerHTML = playersHTML || 
            '<div class="empty-state">No players available</div>';
    }

    function updateTournamentHistory() {
        const tournamentHistoryHTML = state.tournamentHistory.slice().reverse().map((tournament, index) => {
            const date = new Date(tournament.startTime);
            const formattedDate = date.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric',
                year: 'numeric'
            });
            
            const winner = tournament.results?.[0]?.playerName || 'N/A';
            const participants = tournament.participants?.length || 0;
            const matchesCount = tournament.matches?.length || 0;
            
            return `
                <div class="history-item">
                    <div class="history-header">
                        <div class="history-title">${tournament.name}</div>
                        <div class="history-meta">${formattedDate}</div>
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.9rem; margin: 10px 0;">
                        Season ${tournament.season || 1} ‚Ä¢ Tournament ${tournament.positionInSeason || 1}/4 ‚Ä¢ 
                        <span class="${tournament.type === 'single-elimination' ? 'match-status-badge match-status-completed' : 'match-status-badge match-status-pending'}" 
                              style="font-size: 0.7rem; padding: 2px 8px;">
                            ${tournament.type === 'single-elimination' ? 'üèÜ Elimination' : '‚ôüÔ∏è Swiss'}
                        </span>
                    </div>
                    <div class="history-stats">
                        <div class="history-stat">
                            <span>üë•</span>
                            <span>${participants} players</span>
                        </div>
                        <div class="history-stat">
                            <span>‚öîÔ∏è</span>
                            <span>${matchesCount} matches</span>
                        </div>
                        <div class="history-stat">
                            <span>üèÜ</span>
                            <span>${winner.substring(0, 12)}</span>
                        </div>
                    </div>
                    
                    <!-- Bouton pour voir les d√©tails -->
                    <button class="history-expand-btn" onclick="toggleHistoryDetails(${index})">
                        üìä View Details
                    </button>
                    
                    <!-- D√©tails de l'historique (cach√©s par d√©faut) -->
                    <div class="history-details" id="historyDetails${index}">
                        ${tournament.results ? `
                            <h4 style="margin: 15px 0 10px 0; color: var(--text-primary);">Final Rankings:</h4>
                            <table class="history-details-table">
                                <thead>
                                    <tr>
                                        <th>Rank</th>
                                        <th>Player</th>
                                        <th>Wins</th>
                                        <th>Losses</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${tournament.results.slice(0, 5).map((result, idx) => `
                                        <tr>
                                            <td>${idx + 1}</td>
                                            <td>${result.playerName}</td>
                                            <td>${result.wins || 0}</td>
                                            <td>${result.losses || 0}</td>
                                            <td>${result.points || 0}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        ` : ''}
                        
                        ${tournament.matches && tournament.matches.length > 0 ? `
                            <h4 style="margin: 15px 0 10px 0; color: var(--text-primary);">Notable Matches:</h4>
                            <table class="history-details-table">
                                <thead>
                                    <tr>
                                        <th>Round</th>
                                        <th>Match</th>
                                        <th>Winner</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${tournament.matches.slice(0, 3).map(match => `
                                        <tr>
                                            <td>${match.round || 1}</td>
                                            <td>${match.player1?.name || 'Player 1'} vs ${match.player2?.name || 'Player 2'}</td>
                                            <td>${match.winner ? (match.winner === match.player1?.id ? match.player1.name : match.player2.name) : 'Pending'}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        ` : ''}
                    </div>
                </div>
            `;
        }).join('');
        
        document.getElementById('tournamentHistoryList').innerHTML = tournamentHistoryHTML || 
            '<div class="empty-state">No tournament history yet</div>';
        
        document.getElementById('totalTournaments').textContent = state.tournamentHistory.length;
    }

    // Fonction pour afficher/masquer les d√©tails de l'historique
    function toggleHistoryDetails(index) {
        const detailsDiv = document.getElementById(`historyDetails${index}`);
        detailsDiv.classList.toggle('expanded');
        
        const button = event.target;
        if (detailsDiv.classList.contains('expanded')) {
            button.innerHTML = 'üìä Hide Details';
        } else {
            button.innerHTML = 'üìä View Details';
        }
    }

    function updateSeasonTimeline() {
        const tournamentInSeason = (state.tournamentCount % 4) + 1;
        const seasonTimelineHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                ${[1, 2, 3, 4].map(num => `
                    <div style="text-align: center; flex: 1;">
                        <div style="width: 40px; height: 40px; margin: 0 auto 10px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
                            background: ${num === tournamentInSeason ? 'var(--accent)' : num < tournamentInSeason ? 'var(--success)' : 'var(--secondary)'};
                            color: white; font-weight: 600;">
                            ${num}
                        </div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">
                            ${num === 4 ? 'Elimination' : 'Swiss'}
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
        
        document.getElementById('seasonTimeline').innerHTML = seasonTimelineHTML;
        
        // Update season progress
        const seasonProgress = (tournamentInSeason / 4) * 100;
        document.getElementById('seasonProgressText').textContent = `${tournamentInSeason}/4`;
        document.getElementById('seasonProgressFill').style.width = `${seasonProgress}%`;
    }

    function updateStatistics() {
        const totalPlayers = state.players.length;
        const totalMatches = state.tournamentHistory.reduce((sum, t) => sum + (t.matches?.length || 0), 0) + 
                            (state.activeTournament?.matches?.length || 0);
        
        const totalWins = state.players.reduce((sum, p) => sum + (p.wins || 0), 0);
        const totalLosses = state.players.reduce((sum, p) => sum + (p.losses || 0), 0);
        const totalElo = Object.values(state.eloRatings).reduce((sum, elo) => sum + elo, state.systemSettings.initialElo * totalPlayers);
        
        const avgElo = totalPlayers > 0 ? Math.round(totalElo / totalPlayers) : state.systemSettings.initialElo;
        const winRate = totalWins + totalLosses > 0 ? Math.round((totalWins / (totalWins + totalLosses)) * 100) : 0;
        
        document.getElementById('totalPlayers').textContent = totalPlayers;
        document.getElementById('totalMatches').textContent = totalMatches;
        document.getElementById('avgElo').textContent = avgElo;
        document.getElementById('winRate').textContent = `${winRate}%`;
    }

    function updateRecentMatches() {
        const recentMatches = [];
        
        // Add matches from active tournament
        if (state.activeTournament?.matches) {
            state.activeTournament.matches
                .filter(m => m.winner)
                .forEach(m => {
                    recentMatches.push({
                        ...m,
                        tournament: state.activeTournament.name,
                        date: m.endedAt || state.activeTournament.startTime
                    });
                });
        }
        
        // Add matches from tournament history
        state.tournamentHistory.forEach(tournament => {
            tournament.matches
                ?.filter(m => m.winner)
                .slice(0, 2)
                .forEach(m => {
                    recentMatches.push({
                        ...m,
                        tournament: tournament.name,
                        date: m.endedAt || tournament.startTime
                    });
                });
        });
        
        // Sort by date and take top 8
        recentMatches.sort((a, b) => new Date(b.date) - new Date(a.date));
        const topRecentMatches = recentMatches.slice(0, 8);
        
        const recentMatchesHTML = topRecentMatches.map(match => {
            const date = new Date(match.date);
            const timeAgo = getTimeAgo(date);
            
            return `
                <div style="padding: 12px; border-bottom: 1px solid var(--border);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <div>
                            <span style="font-weight: 600; color: var(--success);">${match.player1.name.substring(0, 12)}</span>
                            <span style="margin: 0 8px; color: var(--text-secondary);">vs</span>
                            <span style="font-weight: 600;">${match.player2.name.substring(0, 12)}</span>
                        </div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">
                            ${timeAgo}
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">
                            ${match.tournament.substring(0, 20)}...
                        </div>
                        <div style="font-size: 0.9rem; font-weight: 500; color: var(--accent);">
                            üèÜ ${match.winner === match.player1.id ? match.player1.name.substring(0, 10) : match.player2.name.substring(0, 10)}
                        </div>
                    </div>
                </div>
            `;
        }).join('');
        
        document.getElementById('recentMatchesList').innerHTML = recentMatchesHTML || 
            '<div class="empty-state">No recent matches</div>';
    }

    function getTimeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + "y ago";
        
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + "mo ago";
        
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + "d ago";
        
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + "h ago";
        
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + "m ago";
        
        return Math.floor(seconds) + "s ago";
    }

    function renderChart() {
        const ctx = document.getElementById('seasonChart').getContext('2d');
        
        if (chart) {
            chart.destroy();
        }
        
        const topPlayers = [...state.players]
            .sort((a, b) => {
                if (a.elo !== undefined && b.elo !== undefined) {
                    return b.elo - a.elo;
                }
                return (b.points || 0) - (a.points || 0);
            })
            .slice(0, 5);
        
        const tournamentCount = Math.min(state.tournamentCount, 4);
        const labels = ['Start'];
        for (let i = 1; i <= tournamentCount; i++) {
            labels.push(`T${i}`);
        }
        
        const colors = [
            'rgb(228, 63, 90)',
            'rgb(31, 64, 104)',
            'rgb(46, 204, 113)',
            'rgb(243, 156, 18)',
            'rgb(155, 89, 182)'
        ];
        
        const theme = document.body.getAttribute('data-theme') || 'light';
        const gridColor = theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
        const textColor = theme === 'dark' ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)';
        
        chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: topPlayers.map((player, index) => ({
                    label: player.name,
                    data: player.history?.slice(0, 1 + tournamentCount) || Array(1 + tournamentCount).fill(0),
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    borderWidth: 3,
                    tension: 0.3,
                    pointRadius: 6,
                    pointHoverRadius: 8,
                    pointBackgroundColor: colors[index % colors.length],
                    fill: true
                }))
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            color: textColor,
                            font: {
                                family: 'Inter',
                                size: 12
                            },
                            padding: 20,
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: theme === 'dark' ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.9)',
                        titleColor: textColor,
                        bodyColor: textColor,
                        borderColor: 'var(--accent)',
                        borderWidth: 1,
                        cornerRadius: 8,
                        padding: 12
                    }
                },
                scales: {
                    x: {
                        grid: {
                            color: gridColor
                        },
                        ticks: {
                            color: textColor
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: gridColor
                        },
                        ticks: {
                            color: textColor
                        },
                        title: {
                            display: true,
                            text: 'Points',
                            color: textColor
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'nearest'
                },
                animation: {
                    duration: 1000,
                    easing: 'easeOutQuart'
                }
            }
        });
    }

    function updateSeasonInfo() {
        document.getElementById('currentSeason').textContent = state.season;
        document.getElementById('currentSeasonNum').textContent = state.season;
        document.getElementById('currentChampion').textContent = state.champion;
        
        updateAutoQualifiers();
    }

    // Filter Players Function
    function filterPlayers(filterType) {
        const searchTerm = document.getElementById('searchPlayers').value.toLowerCase();
        const items = document.querySelectorAll('.player-item');
        
        document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
        
        items.forEach(item => {
            const playerName = item.querySelector('.player-name').textContent.toLowerCase();
            const playerRank = item.querySelector('.player-tag').textContent.toLowerCase();
            
            let matchesSearch = playerName.includes(searchTerm);
            let matchesFilter = true;
            
            const rankValue = parseRank(playerRank);
            
            switch(filterType) {
                case 'kyu':
                    matchesFilter = playerRank.includes('k');
                    break;
                case 'dan':
                    matchesFilter = playerRank.includes('d');
                    break;
                case 'low':
                    matchesFilter = rankValue >= 10 && rankValue <= 30;
                    break;
                case 'mid':
                    matchesFilter = (rankValue >= 1 && rankValue <= 5) || playerRank === '1k';
                    break;
                case 'high':
                    matchesFilter = rankValue >= 5 && rankValue <= 9 && playerRank.includes('d');
                    break;
                case 'all':
                default:
                    matchesFilter = true;
            }
            
            item.style.display = matchesSearch && matchesFilter ? 'flex' : 'none';
        });
    }

    function parseRank(rank) {
        const match = rank.match(/(\d+)([kd])/);
        if (match) {
            return parseInt(match[1]);
        }
        return 0;
    }

    // Helper Functions
    function selectAllPlayers() {
        document.querySelectorAll('.enroll-check').forEach(checkbox => {
            checkbox.checked = true;
        });
    }

    function deselectAllPlayers() {
        document.querySelectorAll('.enroll-check').forEach(checkbox => {
            checkbox.checked = false;
        });
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        const savedTheme = localStorage.getItem('meijin-theme') || 'dark';
        document.body.setAttribute('data-theme', savedTheme);
        document.getElementById('themeIcon').textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        
        document.getElementById('searchPlayers').addEventListener('input', () => filterPlayers('all'));
        
        showNotification('Meijin Go System Pro loaded successfully', 'success');
    });

    // =================================================================
    // EXPOSER LES FONCTIONS AU NIVEAU GLOBAL
    // =================================================================

    // Fonctions originales
    window.toggleTheme = toggleTheme;
    window.loginAdmin = loginAdmin;
    window.logoutAdmin = logoutAdmin;
    window.addNewPlayer = addNewPlayer;
    window.startNewTournament = startNewTournament;
    window.createManualMatch = createManualMatch;
    window.swapMatchColors = swapMatchColors;
    window.setMatchWinner = setMatchWinner;
    window.endTournament = endTournament;
    window.generateSwissPairs = generateSwissPairs;
    window.clearCurrentMatches = clearCurrentMatches;
    window.selectAllPlayers = selectAllPlayers;
    window.deselectAllPlayers = deselectAllPlayers;
    window.filterPlayers = filterPlayers;
    window.switchTab = switchTab;

    // Nouvelles fonctions
    window.swapAllMatchColors = swapAllMatchColors;
    window.randomizeAllColors = randomizeAllColors;
    window.swapSelectedPlayers = swapSelectedPlayers;
    window.toggleManualColor = toggleManualColor;
    window.createMultipleMatches = createMultipleMatches;
    window.filterHistory = filterHistory;
    window.toggleHistoryDetails = toggleHistoryDetails;
    window.resetAllMatchColors = resetAllMatchColors;
    window.clearAllMatches = clearAllMatches;
    window.randomizeAllMatches = randomizeAllMatches;
    window.exportTournamentData = exportTournamentData;
    window.loadMatchForEditing = loadMatchForEditing;
    window.swapMatchPlayers = swapMatchPlayers;
    window.saveMatchChanges = saveMatchChanges;
    window.deleteSelectedMatch = deleteSelectedMatch;
    window.setBulkWinner = setBulkWinner;
    window.editMatchManually = editMatchManually;
</script>
</body>
</html>
